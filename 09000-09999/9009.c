#include <stdio.h>

/*
문제 : 자연수 N(N <= 10^9)이 주어질 때, 이 수를 서로 다른 피보나치 수의 합으로 나타내는 방법 가운데
가장 사용하는 피보나치 수의 개수가 적은 것을 구한다.

해결 방법 : 만약 피보나치 번째수가 연속한 두 수의 합이 나온다면 더 큰 수의 합으로 바꿀 수 있다.
또한, 같은 피보나치 수 2개는 다음 피보나치 수와 2개 전의 피보나치 수의 합으로 바꿀 수 있다.
따라서, 이를 이용하면 가장 큰 피보나치 수의 합부터 계산하더라도 항상 서로 다른 피보나치 수의 합으로 쓸 수 있음을 알 수 있다.
또한, 이 경우 연속하여 피보나치 수를 선택할 일이 없으므로 최적의 방법이 되기도 한다.
따라서, 현재 수 이하의 가장 큰 피보나치 수부터 차례로 구해나가면 된다. 

주요 알고리즘 : 수학, 그리디 알고리즘

출처 : Daejeon 2012I D번
*/

int fibo[44], res[64];

int main(void) {
    int t, n, p;
    fibo[0] = 1;
    fibo[1] = 2;
    for (int i = 2;i < 44; i++) {
        fibo[i] = fibo[i - 1] + fibo[i - 2];
    }
    scanf("%d", &t);
    for (int tt = 0; tt < t; tt++) {
        scanf("%d", &n);
        p = 0;
        while (n > 0) {
            for (int i = 43; i >= 0; i--) {
                if (fibo[i] <= n) {
                    n -= fibo[i];
                    res[p++] = fibo[i];
                    break;
                }
            }
        }
        for (int i = p - 1; i >= 0; i--) {
            printf("%d ", res[i]);
        }
        printf("\n");
    }
    return 0;
}