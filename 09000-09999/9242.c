#include <stdio.h>
#include <string.h>

/*
문제 : 2자리 이상 8자리 이하의 수가 디지털 문자 형태로 주어진다. 이 수가 6으로 나누어 떨어지는지 여부를 구한다.
단, 잘못된 문자가 있는 경우 나누어 떨어지지 않는 것이다. 주어지는 수는 0으로 시작할 수 있다.

해결 방법 : 먼저 문자열의 길이를 통해 수의 길이를 구한다. 만약 길이가 고르지 않거나 수의 길이가 나올 수 없는 문자열의 길이라면
잘못된 문자가 있는 것이다. 그 다음에는, 비트마스킹을 통해 각 위치에 있는 수들을 확인하고 해당하는 문자들을 구한다.
해당하는 문자가 없다면 잘못된 문자이다. 잘못된 문자가 없다면 해당하는 문자로 수를 만들 수 있다.
이제 만들어진 수가 6으로 나누어 떨어지는지 확인하면 된다.

주요 알고리즘 : 구현, 파싱, 비트마스킹

출처 : NCPC 2013 F번
*/

char cod[8][128];
int bitm[10] = { 31599, 18724, 29671, 31207, 18925, 31183, 31695, 18727, 31727, 31215 }; //비트마스킹을 통해 나온 각 숫자
int b10[16];

int main(void) {
    int l = -1, r = 0, b, t;
    for (int i = 0; i < 5; i++) {
        fgets(cod[i], 100, stdin);
    }
    for (int i = 0; i < 5; i++) {
        if (cod[i][strlen(cod[i]) - 1] == '\n') cod[i][strlen(cod[i]) - 1] = '\0'; //문자열 끝의 개행 삭제
        if ((strlen(cod[i]) & 3) != 3) {
            printf("BOOM!!"); //길이가 잘못된 경우
            return 0;
        }
        if (i == 0) {
            l = (strlen(cod[i]) + 1) >> 2;
            if (l < 2 || l > 8) return 1; //길이가 범위 안에 없는 경우(주어지지 않음)
        }
        else {
            if (((strlen(cod[i]) + 1) >> 2) != l) {
                printf("BOOM!!"); //길이가 균일하지 않은 경우
                return 0;
            }
        }
    }
    b10[0] = 1;
    for (int i = 1; i < l; i++) b10[i] = b10[i - 1] * 10;
    for (int i = 0; i < l; i++) {
        b = 0;
        for (int j = 0; j < 5; j++) {
            for (int k = 0; k < 3; k++) {
                b += ((cod[j][k + i * 4] == '*') << (j * 3 + k)); //비트마스킹
            }
        }
        t = 0;
        for (int j = 0; j < 10; j++) {
            if (b == bitm[j]) {
                r += b10[l - i - 1] * j; //비교하여 같은 수가 있는 경우
                t = 1;
            }
        }
        if (t == 0) {
            printf("BOOM!!"); //같은 수가 없는 경우
            return 0;
        }
    }
    if (r % 6) printf("BOOM!!"); //6의 배수가 아닌 경우
    else printf("BEER!!"); //6의 배수인 경우
    return 0;
}