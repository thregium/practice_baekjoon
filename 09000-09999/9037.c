#include <stdio.h>

/*
문제 : N(N <= 10)명이 원형으로 앉아 각자 C_i(C_i <= 30)개의 사탕을 갖고 있다. 자신의 오른쪽에 있는 사람에게
자신이 가진 사탕의 절반을 주고 사탕이 홀수개가 되면 사탕 한 개를 받는 것이 한 라운드라고 하면
모든 사람이 가진 사탕의 수가 같아지는 시점은 몇 라운드가 끝난 후인지 구한다.
단, 첫 라운드가 시작하기 전 사탕이 홀수개인 경우 사탕 한 개를 받고 시작한다.

해결 방법 : 먼저 사탕의 개수를 입력받고 사탕이 홀수개인 경우 1개를 받는다. 그 이후로는 모두의 사탕 수가 같은지 확인하고
다르다면 다음 라운드에 각 사람의 사탕 수가 얼마인지를 시뮬레이션을 통해 구한다. 이때, 직접 각 사람의 사탕 수를 구하면
간섭이 일어나 다른 결과가 나올 수 있으므로 임시적으로 다른 배열에 저장해 두어야 한다.
전부 확인한 다음 임시 배열에서 다시 원래 배열로 값들을 옮겨두면 된다.
모두의 사탕 수가 같아지면 그때까지 흐른 라운드 수를 출력한다.

주요 알고리즘 : 구현, 시뮬레이션

출처 : Seoul 2009I B번
*/

int candy[16], nt[16];

int main(void) {
    int t, n, r, tmp;
    scanf("%d", &t);
    for (int tt = 0; tt < t; tt++) {
        scanf("%d", &n);
        for (int i = 0; i < n; i++) {
            scanf("%d", &candy[i]);
            if (candy[i] & 1) candy[i]++;
        }
        r = 0;
        while (1) {
            tmp = 1;
            for (int i = 1; i < n; i++) {
                if (candy[i] != candy[i - 1]) tmp = 0;
            }
            if (tmp) {
                printf("%d\n", r);
                break;
            }
            for (int i = 0; i < n; i++) {
                nt[i] += (candy[i] >> 1);
                nt[(i + 1) % n] += (candy[i] >> 1);
            }
            for (int i = 0; i < n; i++) {
                candy[i] = nt[i];
                nt[i] = 0;
                if (candy[i] & 1) candy[i]++;
            }
            r++;
        }
    }
    return 0;
}