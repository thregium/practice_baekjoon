#include <stdio.h>

/*
문제 : 3 * 3 영역에 동전들이 각각 놓여있다. 이때, 어떤 가로, 세로, 대각선 줄에 있는 동전을 전부 뒤집는 연산이 가능하다면
모든 동전을 같은 면으로 만들기 위해 필요한 최소 연산 횟수를 구한다. 같은 면으로 만드는 것이 불가능하다면
-1을 출력하면 된다.

해결 방법 : 모든 경우의 수는 가로 3줄, 세로 3줄, 대각선 2줄을 각각 뒤집거나 뒤집지 않는 경우로 총 2^8 = 256가지이다.
따라서, 이 경우들을 직접 해보며 연산 횟수를 구하면 된다. 이는 비트마스킹을 통해 해결 가능하다.(코드 참조)

주요 알고리즘 : 브루트 포스, 비트마스킹

출처 : Seoul 2004I F번
*/

int face[16];

int main(void) {
    int t, res, head, cnt, tmp;
    char c;
    scanf("%d", &t);
    for (int tt = 0; tt < t; tt++) {
        for (int i = 0; i < 9; i++) {
            scanf(" %c", &c);
            if (c == 'H') face[i] = 1; //각 면을 수로 변환
            else face[i] = 0;
        }
        res = 103000;
        for (int i = 0; i < (1 << 8); i++) {
            head = 0, cnt = 0;
            for (int j = 0; j < 8; j++) {
                if (i & (1 << j)) cnt++;
            }
            for (int j = 0; j < 9; j++) {
                tmp = ((face[j] + !!(i & (1 << (j % 3))) + !!(i & (1 << (j / 3 + 3)))) & 1); //원래 상태, 가로줄, 세로줄
                if (!(j & 3) && (i & 64)) tmp = !tmp; // \방향 대각선 상태 반전
                if ((j == 2 || j == 4 || j == 6) && (i & 128)) tmp = !tmp; // /방향 대각선 상태 반전
                head += tmp; //최종적으로 해당 경우에서 해당 칸의 상태
            }
            if (head == 0 || head == 9) {
                if (cnt < res) res = cnt; //모든 면이 같아졌는지 확인한다.
            }
        }
        printf("%d\n", res == 103000 ? -1 : res);
    }
    return 0;
}