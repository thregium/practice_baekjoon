#include <stdio.h>
#define INF 1012345678

/*
문제 : N(N <= 1000)개의 발판이 있다. 1번 발판에서 N번 발판으로 가는데 드는 최소 비용을 구한다.
처음에는 1칸 단위로 움직일 수 있고, 오른쪽으로 갈 때 마다 움직이는 단위가 1씩 늘어난다. 발판의 밖으로는 갈 수 없다.
또한, 각 발판을 밟을 때마다 고유한 값(<= 500, 자연수)만큼 비용을 내야 한다.

해결 방법 : 각 움직이는 단위와 발판의 번호를 변수로 두고 DP를 진행한다. 움직이는 단위를 1부터 시작해 차례로 늘려간다.
단위가 0인 경우에는 1번 발판은 0으로, 1번 발판을 제외한 나머지는 무한대로 초기화한다.
매 단위마다 오른쪽으로 움직이는 경우를 미리 확인한 다음, 다시 왼쪽으로 이동하며 왼쪽으로 움직이는 경우를 확인한다.
움직이지 못하는 경우는 무한대로 계산한다. 단위가 N - 1이 되면 더이상 움직일 수 없으므로 종료하고,
N번 발판의 비용 가운데 가장 작은 것을 구하면 된다.

주요 알고리즘 : DP

출처 : CHCI 2008CR 2번 / 2008RJ 4번
*/

int mem[1024][1024], cost[1024];

int main(void) {
    int n, r = INF;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &cost[i]);
        mem[0][i] = INF;
    }
    mem[0][1] = 0;
    for (int i = 1; i < n; i++) {
        for (int j = 1; j <= n; j++) {
            mem[i][j] = ((j > i) ? mem[i - 1][j - i] + cost[j] : INF);
        }
        for (int j = n; j >= 1; j--) {
            if (j + i <= n && mem[i][j + i] + cost[j] < mem[i][j]) mem[i][j] = mem[i][j + i] + cost[j];
        }
    }
    for (int i = 0; i < n; i++) {
        if (mem[i][n] < r) r = mem[i][n];
    }
    printf("%d", r);
    return 0;
}