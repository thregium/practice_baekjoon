#include <stdio.h>
#define MOD 1000000003

/*
문제 : N(N <= 1000)개의 색이 있는 색상환에서 인접한 색을 고르지 않고 K(K <= N)개의 색을 고르는 방법의 수를 구한다.

해결 방법 : 1번째 색을 고르는 경우와 고르지 않는 경우를 나누어 각각 DP를 진행한다.
각 경우에서 고르는 방법은 N - 2개의 색 가운데 K - 1개를 고르는 방법(현재 칸을 고르는 경우)의 수에
N - 1개의 색 가운데 K개를 고르는 방법(현재 칸을 고르지 않는 경우)의 수를 더한 것과 같다.
최종적인 가짓수는 1번째 색을 고르지 않은 경우 N개의 색 가운데 K개를 고른 방법에 1번째 색을 고른 경우 N - 1개의 색 가운데
K개를 고른 방법의 수를 더한 것과 같다.

주요 알고리즘 : DP

출처 : 정올 2010지 중4/고3번
*/

int mem[1024][1024][2];

int main(void) {
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++) {
        mem[i][1][0] = i - 1;
        mem[i][1][1] = 1;
    }
    for (int i = 2; i <= n; i++) {
        for (int j = 2; j <= k; j++) {
            mem[i][j][0] = (mem[i - 2][j - 1][0] + mem[i - 1][j][0]) % MOD;
            mem[i][j][1] = (mem[i - 2][j - 1][1] + mem[i - 1][j][1]) % MOD;
        }
    }
    printf("%d", (mem[n][k][0] + mem[n - 1][k][1]) % MOD);
    return 0;
}