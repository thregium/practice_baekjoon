#include <stdio.h>

/*
문제 : N(N <= 100)개의 비트로 이루어진 문자열 가운데 부분 문자열 '11'이 K(K <= N)회 등장하는 문자열의 수를 구한다.

해결 방법 : 각 N, K에 마지막 문자가 0, 1일 때의 문자열 개수를 상태로 DP를 시행한다.
마지막 문자가 0인 경우, N - 1, K에서 나올 수 있는 문자열의 개수가 해당 상태의 값이 된다.
1인 경우에는 K가 0이라면 N - 1, K에서 마지막 문자가 0일 때의 개수가 되고, 1 이상이라면 그 값에 N - 1, K - 1에서
마지막 문자가 1일 때의 개수가 된다.

주요 알고리즘 : DP

출처 : GNY 2009 F번
*/

long long mem[128][128][2];

int main(void) {
    mem[0][0][0] = 1;
    for (int i = 1; i <= 100; i++) {
        for (int j = 0; j <= 100; j++) {
            mem[i][j][0] = mem[i - 1][j][0] + mem[i - 1][j][1];
            mem[i][j][1] = mem[i - 1][j][0] + (j > 0 ? mem[i - 1][j - 1][1] : 0);
        }
    }
    int t, n, k;
    scanf("%d", &t);
    for (int tt = 0; tt < t; tt++) {
        scanf("%d %d", &n, &k);
        printf("%lld\n", mem[n][k][0] + mem[n][k][1]);
    }
    return 0;
}