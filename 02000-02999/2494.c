#include <stdio.h>
#define INF 987654321

/*
문제 : N(N <= 10000)자리 자물쇠가 있다. 이 자물쇠의 칸을 왼쪽(숫자가 커지는 방향)으로 돌리면 그 칸과 아래 모든 칸이 같이 왼쪽으로 돌아간다.
오른쪽(숫자가 작아지는 방향)으로 돌리는 경우에는 다른 칸이 움직이지는 않는다. 현재 자물쇠의 숫자들과 만드려고 하는 자물쇠의 숫자들이 주어지면,
만드려고 하는 수를 만들기까지 최소 몇 칸 회전이 필요한지 구하고 그렇게 만드는 방법을 한 가지 출력한다.

해결 방법 : 다이나믹 프로그래밍을 통해 해결할 수 있다. 각 칸과 이하 칸들이 돌아간 정도에 대해 최소 회전수를 저장해놓는다.
이하 칸들이 두 수의 차만큼 돌아가지 않은 이상 필요한 최소 회전수는 이전 칸의 동일하게 돌아간 상태의 최소 회전수에서 오른쪽으로 돌린 횟수를 더한 것과 같다.
만약 두수의 차만큼 돌아갔다면 왼쪽으로 돌리는 것도 가능해진다. 왼쪽으로 돌리는 경우는 이전 칸의 모든 상태에 대해 가능하다.
회전이 필요한 횟수는 마지막 상태에서 돌아간 정도들 가운데 가장 값이 작은 것을 고르면 된다.
그렇게 만드는 방법을 확인하기 위해서는 마지막에 고른 값의 돌아간 상태에서 출발해서 이전칸으로 한칸씩 가야 한다.
만약 이전 칸의 같은 상태에서 오른쪽으로 돌려서 이동한 횟수를 더한 것이 현재 칸의 상태와 같다면 그 칸은 오른쪽으로 돌려서 최소 회전 수를 만들 수 있는 것이다.
그렇지 않다면 왼쪽으로 돌려본다. 반드시 되는 상태가 있을 것이므로 왼쪽으로 돌린다.
이를 다시 반복하여 맨 앞 칸까지 이동한 다음 역순으로 출력하면 된다.

주요 알고리즘 : 다이나믹 프로그래밍, 역추적, 수학

출처 : 정올 2009지 초5/중3번
*/

int a[10240], b[10240], mem[10240][10], res[10240];

int small(int a, int b) {
    return a < b ? a : b;
}

int main(void) {
    int n, sub, r = INF, pos, turn;
    char buff;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf(" %c", &buff);
        a[i] = buff - '0';
    }
    for (int i = 1; i <= n; i++) {
        scanf(" %c", &buff);
        b[i] = buff - '0';
    }
    mem[0][0] = 0;
    for (int i = 1; i < 10; i++) mem[0][i] = INF;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < 10; j++) {
            sub = (b[i] - a[i] + 10) % 10;
            mem[i][j] = mem[i - 1][j] + (10 - sub + j) % 10; //왼쪽으로 돌리기
            if (j == sub) {
                for (int k = 0; k < 10; k++) {
                    mem[i][j] = small(mem[i][j], mem[i - 1][k] + (sub + 10 - k) % 10); //오른쪽으로 돌리기
                }
            }
        }
    }
    for (int i = 0; i < 10; i++) {
        if (mem[n][i] < r) {
            r = mem[n][i];
            turn = i;
        }
    }
    printf("%d\n", r);
    for (pos = n; pos > 0; pos--) {
        //역추적
        sub = (b[pos] - a[pos] + 10) % 10;
        if (mem[pos][turn] == mem[pos - 1][turn] + (10 - sub + turn) % 10) {
            res[pos] = -((10 - sub + turn) % 10);
        }
        else {
            for (int i = 0; i < 10; i++) {
                if (mem[pos][turn] == mem[pos - 1][i] + (sub + 10 - i) % 10) {
                    res[pos] = (sub + 10 - i) % 10;
                    turn = i;
                    break;
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        if (!res[i]) continue;
        printf("%d %d\n", i, res[i]);
    }
    
    return 0;
}