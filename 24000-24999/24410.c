#include <stdio.h>

/*
문제 : N(N <= 1000)개의 자연수(<= 10^6)가 스택에 쌓여 있다. 다음 연산들을 10만회 이내로 하여
스택에 주어진 형태로 수들을 쌓는 방법을 출력한다.
1. 스택의 맨 위에 1 추가
d. 스택 맨 위의 값 복사
+. 스택 맨 위 두 값을 꺼내서 더한 후 스택에 추가하고 나머지 값들은 1씩 감소시킴

해결 방법 : 스택의 위에서부터 수들을 쌓는 방법을 거꾸로 계산해나가면서 위에서 +를 쓴 횟수만큼
아래 수들의 값을 더한 다음 그 수에 대해 쌓는 방법을 찾아나간다. 이를 반복하여 스택 전체에 대해
쌓는 방법을 만든 다음 전체 과정을 뒤집고 출력하면 된다.
특정한 수에 대해 수를 쌓는 방법은 1이 되기까지 *2와 *2+1의 과정만을 사용할 수 있다는 점만을 이용해
짝수면 앞에 d+를, 홀수면 d+1+를 더해나간 다음 1이 되면 앞에 1을 붙이는 것이다.
이를 통해 11 * 10^5 이하인 모든 수들에 대해 100회 이내로 수들을 쌓을 수 있기 때문에
반드시 10만회 이내로 수들을 쌓을 수 있다.

주요 알고리즘 : 수학, 구성적

출처 : NAQ 2021 J번
*/

int x[103000];
char res[103000];

void swap(char* a, char* b) {
    char t = *a;
    *a = *b;
    *b = t;
}

int main(void) {
    int n, rp = 0, plus = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &x[i]);
        //x[i] = 103000;
    }
    for (int i = n - 1; i >= 0; i--) {
        x[i] += plus;
        while (x[i] > 1) {
            if (x[i] & 1) {
                res[rp++] = '+';
                res[rp++] = '1';
                plus++;
            }
            res[rp++] = '+';
            res[rp++] = 'd';
            plus++;
            x[i] >>= 1;
        }
        res[rp++] = '1';
    }
    if (rp > 100000) return 1;
    for (int i = 0, j = rp - 1; i < j; i++, j--) swap(&res[i], &res[j]);
    printf("%s", res);
    //printf("%d", rp);
    return 0;
}