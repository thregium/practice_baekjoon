#include <stdio.h>

/*
문제 : N(N <= 10^6)개의 0으로 된 수열에 대해 K(K <= 10^6)번 다음 연산을 시행한다. (Xi(Xi < N)로 나누어 떨어지는 모든 번호의 수를 1 증가시킨다.)
연산이 끝나면 Q(Q <= 10^6)개의 쿼리에 대해 응답한다. (L과 R이 주어질 때, L과 R 사이의 모든 번호의 수의 합을 출력한다.)

해결 방법 : N * K가 매우 크기 때문에 1번씩 연산을 시행하면 시간 초과가 나게 될 것이다.
그러므로 미리 Xi의 값별로 갯수를 세놓고 연산을 진행해야 한다. 그러면 최악의 경우(1부터 N까지 1개씩 나오는 경우)에도
1 + 1/2 + 1/3 + ... + 1/N 이 log(N)에 수렴하기 때문에 시간초과를 막을 수 있다.
연산이 끝나고 나면 쿼리를 처리할 때에도 이후 업데이트가 없으므로 누적 합을 이용해 (R까지의 합) - (L - 1까지의 합) = (L ~ R의 합)로 풀면 시간 내에 풀 수 있다.

주요 알고리즘 : 구현, 누적 합

출처 : AIPO 2017F 7번
*/

int x[1048576];
long long seq[1048576], ss[1048576];

int main(void) {
    int n, k, xi, q, l, r;
    scanf("%d %d", &n, &k);
    for (int i = 0; i < k; i++) {
        scanf("%d", &xi);
        x[xi]++;
    }
    for (int i = 1; i < n; i++) {
        if (x[i] == 0) continue;
        for (int j = 0; j < n; j += i) {
            seq[j] += x[i];
        }
    }
    for (int i = 1; i <= n; i++) {
        ss[i] = ss[i - 1] + seq[i - 1];
    }
    scanf("%d", &q);
    for (int i = 0; i < q; i++) {
        scanf("%d %d", &l, &r);
        printf("%lld\n", ss[r + 1] - ss[l]);
    }
    return 0;
}
