#include <stdio.h>

/*
문제 : N(N <= 10000)명이 순위 순으로 문제를 푼 시간이 주어진다. 문제는 P(P <= N)개가 있고, 문제를 푼 시간은 올림으로 적용될 때,
모든 사람의 문제를 푼 개수를 찾을 수 있는지 확인하고 가능하다면 순서대로 출력한다. 물론 순위는 문제 -> 시간 순으로 정해진다.

해결 방법 : 어떤 사람의 문제를 푼 시간이 윗 순위 사람의 문제를 푼 시간보다 짧다면 그 사람보다는 문제를 푼 개수가 적을 것이다.
그런데, 이러한 관계가 여러 가지가 나올 수 있으므로 문제를 푼 개수가 많은 사람은 가능한 모든 문제를 풀어야 하고,
적은 사람은 문제를 가능한 적게 풀어야 한다. 이때, 푼 시간이 0인 경우에는 반드시 0문제를 풀었어야 함을 이용해서
가장 많이 푼 사람의 문제 수와 가장 적게 푼 사람의 문제 수를 구할 수 있다. 0인 경우 0문제, 아니라면 각각 문제 수, 1문제이다.
1위부터 순서대로 이동하며 윗 순위보다 푼 시간이 짧은 경우 1문제씩 줄여나가다가 마지막에 도달했을 때 값이
가장 적게 푼 사람의 문제 수와 같다면 해당 값들을 출력, 아니라면 불가능함을 출력하면 된다.

주요 알고리즘 : 그리디 알고리즘

출처 : UKIEPC 2020 C번 // BAPC 2020 C번
*/

int ti[10240], pi[10240];

int main(void) {
    int n, p;
    scanf("%d %d%d", &n, &p, &ti[0]);
    if (ti[0]) pi[0] = p;
    for (int i = 1; i < n; i++) {
        scanf("%d", &ti[i]);
        if (ti[i] == 0) {
            pi[i] = 0;
            if (pi[i - 1] > 1) {
                printf("ambiguous");
                return 0;
            }
        }
        else if (ti[i] < ti[i - 1]) {
            pi[i] = pi[i - 1] - 1;
        }
        else pi[i] = pi[i - 1];
    }
    if ((pi[n - 1] && !ti[n - 1]) || (pi[n - 1] > 1 && ti[n - 1])) printf("ambiguous");
    else {
        for (int i = 0; i < n; i++) {
            printf("%d\n", pi[i]);
        }
    }
    return 0;
}