#include <stdio.h>
#define MOD 1000000007

/*
문제 : H(H <= 100)층의 인간 피라미드를 만드려고 한다. 피라미드는 가장 밑이 H명, 그 다음 층이 H - 1명 ... 하여 가장 위 층은 1명만 존재한다.
이 피라미드에서 무거운 사람이 S명이고, 나머지는 가벼운 사람들이다. 무거운 사람 밑에는 무거운 사람만 들어갈 수 있다면
인간 피라미드를 만드는 방법은 몇 가지인가? 단, 각 가벼운 사람들과 무거운 사람들은 구별하지 않는다.

해결 방법 : 피라미드의 한쪽 끝을 시작점으로 하고, 오른쪽이나 왼쪽으로 넓혀가며 다이나믹 프로그래밍을 한다.
X번째 대각선 줄까지 봤을 때, Y명의 무거운 사람을 써서 만들 수 있는 피라미드의 가짓수를 생각한다.
그런데, 여기서 만들 수 있는 가짓수는 이전 줄에서의 무거운 사람 수와 연관이 있으므로 그 내용도 배열에 추가해야 한다.
따라서, 배열에는 X번째 대각선 줄까지 봤을 때 Y명의 무거운 사람을 쓰고 이전 줄에서 최소 Z명의 무거운 사람을 쓴 경우의 가짓수를 저장한다.
그렇게 되면, mem[x][y][z] = mem[x][y][z + 1] + mem[x - 1][y - z][z - 1]이 된다. Z명 이상을 쓰는 경우는 Z - 1명인 경우를 전부 포함하고,
Z명을 쓰는 경우는 한 칸 적은 피라미드에서 Y - Z명을 쓴 상태에서 Z명보다 1명 적거나 그 이상이 해당 줄에 들어가는 경우이기 때문이다.
따라서, 이 값을 다이나믹 프로그래밍을 통해 얻으면 된다. 이때, Z가 0인 경우 오른쪽 Z - 1은 0으로 계산하고, Y가 Z보다 작은 경우 오른쪽 값은 무시한다.
또한, Z + 1이 Z보다 먼저 계산되므로 3번째 값은 역순으로 계산하여야 한다.

주요 알고리즘 : 다이나믹 프로그래밍

출처 : BAPC 2020P H번
*/

int mem[101][10001][101];

int main(void) {
    int h, s;
    scanf("%d %d", &h, &s);
    mem[0][0][0] = 1;
    for (int i = 1; i <= h; i++) {
        for (int j = 0; j <= ((h * (h + 1)) >> 1); j++) {
            for (int k = i; k >= 0; k--) {
                if (j < k) mem[i][j][k] = mem[i][j][k + 1];
                else mem[i][j][k] = (mem[i][j][k + 1] + mem[i - 1][j - k][k > 0 ? k - 1 : 0]) % MOD;
            }
        }
    }
    printf("%d", mem[h][s][0]);
    return 0;
}