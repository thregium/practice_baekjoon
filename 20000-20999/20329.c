#include <stdio.h>

/*
문제 : 물 속에 직선 형태로 N(N <= 1000)개의 자리가 있고, K(K <= 1000)마리의 물고기가 있다. 물고기는 평소에 움직이지 않다가
미끼를 던지면 양 옆의 물고기가 그 방향으로 한번에 한칸씩 움직인다고 한다. 이때, 물고기들끼리 서로 만나거나 자리 밖으로
나가지 않게 하며 물고기들을 원하는 위치로 움직일 수 있는지 구하고, 가능하다면 그때의 최단시간을 구한다.

해결 방법 : 먼저, 최단시간을 찾는 것은 의외로 쉽다. 현위치와 필요 위치 차이만큼 한쪽 방향으로 움직인 다음,
앞쪽에서는 왼쪽으로 그만큼 움직였을 것이므로 지금까지의 누적 값을 더한다. 여기에 모든 값을 0 이상으로 만들기 위해
최솟값을 각각 빼주면 그것이 최단시간이 된다.(가능하다면)
이제 이것이 가능한지 알아보기 위해 맨 왼쪽부터 한번씩 물고기들을 실제로 움직여가며 원하는 위치까지 갈 수 있는지 해본다.
만약 맨 오른쪽 위치까지 갔음에도 물고기들이 원하는 위치가 아닌 경우에는 원하는 위치로 보내는 것이 불가능한 것이다.

주요 알고리즘 : 그리디 알고리즘

출처 : UKIEPC 2020 A번 // BAPC 2020 A번 // Petro 2021W3 A번
*/

int cur[1024], des[1024], diff[1024];

int main(void) {
    int n, k, min = 0, sum = 0, cnt = 0, p = 0;
    scanf("%d %d", &n, &k);
    for (int i = 0; i < k; i++) {
        scanf("%d", &cur[i]);
    }
    for (int i = 0; i < k; i++) {
        scanf("%d", &des[i]);
    }

    for (int i = 1; i <= k; i++) {
        diff[i] = diff[i - 1] + des[i - 1] - cur[i - 1]; //현위치와 필요 위치 차이의 누적합을 구한다.
        if (diff[i] < min) min = diff[i];
        sum += diff[i];
    }
    for (int i = 0; i <= k; i++) diff[i] -= min; //최솟값을 기준으로 맞춰둔다.(모든 값은 0 또는 양수가 된다.)
    sum -= min * (k + 1); //마찬가지로 최솟값을 기준으로 빼둔다.

    //일단 가능하다면 위에서 구한 합이 최솟값이다. 이제 이 값이 가능한지 확인한다.
    while (cnt < sum) {
        if (p == 0) {
            //맨 왼쪽 위치인 경우
            if (diff[p] == 0 || cur[p] < 3) p++;
            else {
                cur[p]--;
                diff[p]--;
                cnt++;
            }
        }
        else if (p == k) {
            //맨 오른쪽 위치인 경우
            if (diff[p] == 0 || n - cur[p - 1] < 2) {
                printf("impossible");
                return 0;
            }
            else {
                cur[p - 1]++;
                diff[p]--;
                cnt++;
                if (diff[p - 1] > 0) p--;
            }
        }
        else {
            //그 외
            if (diff[p] == 0 || cur[p] - cur[p - 1] < 4) p++; //차이가 0이거나 더 움직일 수 없다면 다음 물고기 확인
            else {
                cur[p - 1]++;
                cur[p]--;
                diff[p]--;
                cnt++;
                if (diff[p - 1] > 0) p--; //앞쪽 칸의 차이가 아직 남은 경우
            }
        }
    }

    printf("%d", sum);
    return 0;
}