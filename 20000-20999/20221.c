#include <stdio.h>
#include <stdlib.h>

/*
문제 : N(N <= 10000)개의 수들로 이루어진 배열이 있을 때, 이 수들에서 6과 9인 자리들을 마음대로 6이나 9로 바꾸었을 때,
정렬이 가능한지 확인하고, 가능하다면 그 값들을 출력한다.

해결 방법 : 각 수들은 앞 수보다 크거나 같으면서 가장 작은 수가 될 때가 최적이 된다.
최적인 값을 찾는 방법으로는 맨 뒷 자리부터 백트래킹을 하는 방법이 있다. 맨 앞부터 해당 자리까지 봤을 때, 나머지 6이 전부 9가 된다면
앞 수보다 크거나 같은지 보고 그렇다면 뒷자리로 이동, 아니라면 이번 자리를 바꾸는 방식이다. 6이라면 9로 바꾸고, 9라면 6으로 바꾼 뒤
앞 자리로 이동, 나머지 수면 그대로 앞 자리로 이동한다. 수의 범위를 벗어났다면 뒤쪽으로 벗어난 경우 그 값이 최적값이고,
앞쪽으로 벗어난 경우 답을 찾지 못한 것이므로 정렬이 불가능하다는 것을 의미한다.

주요 알고리즘 : 그리디 알고리즘, 구현, 백트래킹

출처 : BAPC 2020P I번
*/

long long a[10240], d10[24];

int main(void) {
    int n, p, c, r = 1;
    long long b;
    scanf("%d", &n);
    d10[0] = 1;
    for (int i = 1; i <= 18; i++) d10[i] = d10[i - 1] * 10;
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]);
        p = 0;
        b = a[i];
        for (int j = 0; j <= 18; j++) {
            if (a[i] / d10[j] % 10 == 9) {
                a[i] -= d10[j] * 3;
            }
        }
        for (int j = 0; j <= 18; j++) {
            if (b / d10[j] % 10 == 6) {
                b += d10[j] * 3;
            }
        }
        while (p >= 0 && p <= 18) {
            if ((a[i] - (a[i] % d10[p]) + b % d10[p]) >= a[i - 1]) {
                p--;
                
            }
            else {
                if (a[i] / d10[p] % 10 == 6) {
                    a[i] += d10[p] * 3;
                }
                else if (a[i] / d10[p] % 10 == 9) {
                    a[i] -= d10[p] * 3;
                    p++;
                    if (p > 18) r = 0;
                }
                else {
                    p++;
                    if (p > 18) r = 0;
                }
            }
        }
    }
    if (r) printf("possible\n");
    else {
        printf("impossible\n");
        return 0;
    }
    for (int i = 1; i <= n; i++) {
        printf("%lld\n", a[i]);
        if (a[i] < a[i - 1]) return 1;
    }
    return 0;
}