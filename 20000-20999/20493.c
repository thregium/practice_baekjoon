#include <stdio.h>

/*
문제 : N(N <= 100000)번 방향을 바꾸며 0부터 T(T <= 10^9)의 시간까지 이동하였다. 각 방향을 바꾼 시각과
바꾼 방향(좌, 우)이 주어지면, T에 도착하는 곳의 좌표를 구한다. 1초에 1씩 움직인다.

해결 방법 : 계속 직전 시각과의 차이만큼 움직이면서 좌표를 구해나간다. 방향은 매번 적절히 바꾸면 된다.
마지막으로 T와의 차이만큼 움직이면 그곳이 답이 된다.

주요 알고리즘 : 구현, 시뮬레이션

출처 : 선린 4회예 B번
*/

int dxy[4][2] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };
char buff[16];

int main(void) {
    int n, t, x = 0, y = 0, d = 1, l = 0, tmp;
    scanf("%d %d", &n, &t);
    for (int i = 0; i < n; i++) {
        scanf("%d %s", &tmp, buff);
        x += (tmp - l) * dxy[d][0];
        y += (tmp - l) * dxy[d][1];
        l = tmp;
        if (buff[0] == 'l') d = ((d + 3) & 3);
        else d = ((d + 1) & 3);
    }
    x += (t - l) * dxy[d][0];
    y += (t - l) * dxy[d][1];
    printf("%d %d", x, y);
    return 0;
}