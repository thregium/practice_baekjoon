#include <stdio.h>
#define MOD 1000000009

/*
문제 : 길이 N(N <= 10^6)의 알파벳 대문자 앞에서부터 K(3 <= K <= 26)개로 이루어진 문자열 가운데
"ABABC" 또는 "ABCBC" 문자열이 들어있지 않은 문자열의 개수를 구한다.

해결 방법 : 최근 만들어진 문자 가운데 마지막 문자열이 "ABABC" 또는 "ABCBC"와 일치하는 부분에 대해 경우를 나눈다.
그 다음, 각 경우에 대해 문자가 들어오면 어느 위치로 가는지를 각각 구한다.
"" + "A" = "A", "" + 그 외 문자 = "" / "A" + "A" = "A", "A" + "B" = "AB", "A" + 그 외 문자 = ""
"AB" + "A" = "ABA", "AB" + "C" = "ABC", "AB" + 그 외 문자 = "", "ABA" + "A" = "A", "ABA" + "B" = "ABAB", "ABA" + 그 외 문자 = ""
"ABAB" + "A" = "ABA", "ABAB" + "C" = "ABABC", "ABAB" + 그 외 문자 = "", "ABC" + "A" = "ABC", "ABC" + "B" = "ABCB", "ABC" + 그 외 문자 = ""
"ABCB" + "A" = "A", "ABCB" + "C" = "ABCBC", "ABCB" + 그 외 문자 = ""
이다.
이 경우들을 각각 DP로 하여 넣으면 된다. 해당 경우로 바뀔 수 있는 가짓수를 세면 되는데,
""를 제외한 경우는 항상 이전 상태 1개당 1번씩(문자 1개)만 가능하다. 따라서, 이전 상태들을 확인하고 그대로 더하기만 하면 된다.
""인 경우에는 K에서 해당 상태에서 ""를 제외한 다른 상태가 되는 경우의 수를 뺀 개수를 곱해서 더하면 된다.
마지막에는 길이 N일 때 "ABABC" 또는 "ABCBC"(이 2가지는 계산에서 제외하는 것이 좋다.) 상태를 제외한 모든 상태의 가짓수를 더해주면 된다.

주요 알고리즘 : DP

출처 : 정올 2014지 중4/고3번
*/

long long mem[1048576][8]; //0: "", 1: "A", 2: "AB", 3: "ABA", 4: "ABAB", 5: "ABC", 6: "ABCB"

int main(void) {
    int n, k;
    scanf("%d %d", &n, &k);
    mem[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        mem[i][0] = (mem[i - 1][0] * (k - 1) + (mem[i - 1][1] + mem[i - 1][2] + mem[i - 1][3]) * (k - 2));
        mem[i][0] += (mem[i - 1][4] + mem[i - 1][5] + mem[i - 1][6]) * (k - 2);
        mem[i][0] %= MOD;
        mem[i][1] = (mem[i - 1][0] + mem[i - 1][1] + mem[i - 1][3] + mem[i - 1][5] + mem[i - 1][6]) % MOD;
        mem[i][2] = mem[i - 1][1];
        mem[i][3] = (mem[i - 1][2] + mem[i - 1][4]) % MOD;
        mem[i][4] = mem[i - 1][3];
        mem[i][5] = mem[i - 1][2];
        mem[i][6] = mem[i - 1][5];
    }
    printf("%lld", (mem[n][0] + mem[n][1] + mem[n][2] + mem[n][3] + mem[n][4] + mem[n][5] + mem[n][6]) % MOD);
    return 0;
}