#include <stdio.h>

/*
문제 : M(M <= 1000)개의 벨트와 M + 1개의 바퀴가 있다. 각 벨트는 인접한 두 바퀴를 묶는다.
이때, 첫 바퀴가 1의 속도로 시계방향으로 돈다고 하면, 각 벨트의 형태(꼬인 형, 안 꼬인 형)와
각 벨트에 묶인 두 바퀴의 속도 비(서로소, <= 10^9)가 주어질 때, 마지막 바퀴의 회전 방향과 속도를 구한다.
모든 바퀴의 속도는 10^9 이하의 자연수이다.

해결 방법 : 벨트에 묶인 다음 바퀴의 방향은 꼬인 형태일 때는 반대가 되고, 꼬이지 않았다면 그대로이다.
속도는 두 바퀴의 속도 비를 이전 바퀴의 속도에 곱한 것과 같다.

주요 알고리즘 : 수학

출처 : 정올 2015 초2번
*/

int main(void) {
    int m, a, b, t, r = 1, c = 0;
    scanf("%d", &m);
    for (int i = 0; i < m; i++) {
        scanf("%d %d %d", &a, &b, &t);
        r /= a;
        r *= b;
        if (t) c = !c;
    }
    printf("%d %d", c, r);
    return 0;
}