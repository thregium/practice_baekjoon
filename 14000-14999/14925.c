#include <stdio.h>

/*
문제 : M * N(M, N <= 1000) 크기의 격자에서 모든 칸이 0으로 이루어진 가장 큰 정사각형의 한 변의 길이를 구한다.

해결 방법 : DP를 이용해 해당 위치를 오른쪽 아래의 위치로 하는 가장 큰 정사각형의 크기를 매 칸마다 구해주는 방식으로 해결 가능하다.
만약 어떤 칸이 0이 아니라면 그 칸의 값은 0이 된다. 0인 경우에는 그 칸의 위쪽 또는 왼쪽, 또는 왼쪽 위칸의 값들 가운데
가장 작은 것을 찾은 다음 그 값 + 1이 그 칸의 값이 된다. 위쪽이나 왼쪽은 그쪽 변으로 뻗을 수 있는 가장 긴 변의 길이가 되기 때문이고
왼쪽 위는 그 2개로 볼 수 없는 왼쪽 위 꼭짓점을 살피기 위해서이다. 따라서 이 값은 나머지 두 값의 최솟값보다 많아야 1 작게 된다.

주요 알고리즘 : DP

출처 : 홍익대 2017 H번
*/

int a[1024][1024], mem[1024][1024];

int small(int a, int b) {
    return a < b ? a : b;
}

int main(void) {
    int m, n, r = 0;
    scanf("%d %d", &m, &n);
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            scanf("%d", &a[i][j]);
        }
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (a[i][j]) mem[i][j] = 0;
            else {
                mem[i][j] = small(small(mem[i - 1][j], mem[i][j - 1]), mem[i - 1][j - 1]) + 1;
                if (mem[i][j] > r) r = mem[i][j];
            }
        }
    }
    printf("%d", r);
    return 0;
}