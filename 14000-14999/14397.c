#include <stdio.h>

/*
문제 : N * M(N, M <= 50) 크기의 육각형 형태의 지도가 주어지면 이 지도에서 해변의 길이(한쪽은 물, 한쪽은 땅인 곳)를 구한다.

해결 방법 : 모든 칸은 상하좌우와 인접하고, 추가로 홀수번째 칸은 왼쪽 대각선, 짝수번째 칸은 오른쪽 대각선들과 인접한다.
따라서, N * M 크기의 모든 칸을 확인하며 육지인 칸 가운데 인접한 물의 칸을 전부 더하면 답이 된다.
배열 범위를 벗어나지 않도록 (1, 1)부터 입력받는 것이 좋다.

주요 알고리즘 : 구현
*/

char s[64][64];
int dxyo[6][2] = { {1, 0}, {0, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1} };
int dxye[6][2] = { {1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {0, -1} };

int main(void) {
    int n, m, r = 0;
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%s", s[i] + 1);
    }
    for (int i = 1; i <= n; i += 2) {
        for (int j = 1; j <= m; j++) {
            if (s[i][j] != '#') continue;
            for (int k = 0; k < 6; k++) {
                if (s[i + dxyo[k][0]][j + dxyo[k][1]] == '.') r++;
            }
        }
    }
    for (int i = 2; i <= n; i += 2) {
        for (int j = 1; j <= m; j++) {
            if (s[i][j] != '#') continue;
            for (int k = 0; k < 6; k++) {
                if (s[i + dxye[k][0]][j + dxye[k][1]] == '.') r++;
            }
        }
    }
    printf("%d", r);
    return 0;
}