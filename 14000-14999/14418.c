#include <stdio.h>

/*
문제 : 3개의 직사각형이 있다. 이 직사각형들의 양 변의 길이(<= 100)가 주어지면, 세 직사각형을
붙여서 하나의 정사각형을 만들 수 있는 지 구한다. 직사각형을 돌리는 것이 가능하고, 직사각형끼리
겹쳐서는 안 된다.

해결 방법 : 정사각형을 만드는 두 경우에 대해 선택하는, 그리고 돌리는 모든 경우를 해 보면서
그 중 가능한 것이 있는 지 확인하면 된다. 비트마스킹을 이용할 수 있다.

주요 알고리즘 : 브루트 포스, 케이스 워크, 비트마스킹

출처 : PacNW 2016 X번
*/

int rect[3][2];

int main(void) {
    int r = 0;
    for (int i = 0; i < 3; i++) {
        scanf("%d %d", &rect[i][0], &rect[i][1]);
    }
    for (int i = 0; i < 8; i++) {
        if (rect[0][i & 1] + rect[1][(i >> 1) & 1] == rect[2][(i >> 2) & 1]) {
            if (rect[0][~i & 1] == rect[1][(~i >> 1) & 1]) {
                if (rect[0][~i & 1] + rect[2][(~i >> 2) & 1] == rect[2][(i >> 2) & 1]) r = 1;
            }
        }

        if (rect[0][i & 1] + rect[2][(i >> 2) & 1] == rect[1][(i >> 1) & 1]) {
            if (rect[0][~i & 1] == rect[2][(~i >> 2) & 1]) {
                if (rect[0][~i & 1] + rect[1][(~i >> 1) & 1] == rect[1][(i >> 1) & 1]) r = 1;
            }
        }

        if (rect[1][(i >> 1) & 1] + rect[2][(i >> 2) & 1] == rect[0][i & 1]) {
            if (rect[1][(~i >> 1) & 1] == rect[2][(~i >> 2) & 1]) {
                if (rect[0][~i & 1] + rect[1][(~i >> 1) & 1] == rect[0][i & 1]) r = 1;
            }
        }

        if (rect[0][i & 1] == rect[1][(i >> 1) & 1] && rect[0][i & 1] == rect[2][(i >> 2) & 1]) {
            if (rect[0][~i & 1] + rect[1][(~i >> 1) & 1] + rect[2][(~i >> 2) & 1] == rect[0][i & 1]) r = 1;
        }
    }
    printf("%s", r ? "YES" : "NO");
    return 0;
}