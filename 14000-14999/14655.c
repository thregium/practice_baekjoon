#include <stdio.h>
#include <stdlib.h>

/*
문제 : N(N <= 10000)개의 동전이 일렬로 있고, 각 동전의 앞면과 뒷면에는 절댓값(<= 10000)이 같고 부호가 다른 수가 적혀있다.
이때, 연속한 동전 3개를 뒤집을 수 있다면, 첫 번째 동전의 배열에서 얻을 수 있는 최댓값과
두 번째 동전의 배열에서 얻을 수 있는 최솟값의 차를 구한다.
단, 배열을 벗어나서 끝에서 2개만 뒤집거나 1개만 뒤집는 것도 가능하다.

해결 방법 : 배열의 맨 왼쪽에서 시작해서 현재 상태와 다르다면 동전을 뒤집어본다. 이를 모든 동전에서 시행이 가능하기 때문에
모든 동전을 원하는 상태로 만들 수 있다는 것을 알 수 있다. 따라서, 첫 번째에서는 모든 동전을 양수로 할 수 있고,
두 번째에서는 모든 동전을 음수로 할 수 있는데, 이것의 차는 모든 동전을 양수로 했을 때의 합과 같다.
따라서, 2 * N개 동전의 절댓값 합을 구하면 된다.

주요 알고리즘 : 그리디 알고리즘

출처 : 선린 1회 F번
*/

int main(void) {
    int n, x, r = 0;
    scanf("%d", &n);
    for (int i = 0; i < 2 * n; i++) {
        scanf("%d", &x);
        r += abs(x);
    }
    printf("%d", r);
    return 0;
}
