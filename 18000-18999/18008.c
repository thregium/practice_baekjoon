#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

/*
문제 : 길이 N(N <= 32000)의 문자열을 모스 코드로 변환하려 한다. 이때 변환을 해서 가장 짧은 부호가 나오도록 모스 부호를 재조정한다면,
그때의 길이를 구한다. 점의 길이는 1, 선의 길이는 3이며, 하나의 부호 내 점과 선 사이 간격은 1, 부호 사이의 간격은 3이다.

해결 방법 : 모스 코드로 변환하여 부호가 짧아지게 하려면 단순히 각 부호들의 등장 횟수를 많이 등장한 순으로 정렬한 다음
짧은 부호부터 그 문자로 대응하면 된다. 짧은 부호들을 어떻게 찾는지가 문제인데, 각 부호가 짧은 순으로 나열해 보면
가장 짧은 부호(길이 1)는 1개, 다음으로 짧은 부호(길이 3)는 2개이고, 그 이후로는 이전의 두 부호의 개수 합과 같다.
그 이유는 2개 전의 부호에서 선을 추가하거나, 이전 부호에서 점을 추가하는 경우 다음 길이를 얻을 수 있기 때문이다.
이를 반복하여 가장 짧은 26개의 부호들을 구할 수 있다.
이제 각 부호들을 문자에 대응시켜 각 문자들의 길이의 합를 구한 다음, 공백의 길이(문자의 수 - 1) * 3을 더해주면 된다.

주요 알고리즘 : 그리디 알고리즘, 문자열, 수학

출처 : PacNW 2019 X번 // SEUSA 2019D2 K번
*/

char s[32768];
int cnt[26];
int morse[26] = { 1, 3, 3, 5, 5, 5, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11, 11, 11 };

int cmp1(const void* a, const void* b) {
    int ai = *(int*)a;
    int bi = *(int*)b;
    return ai < bi ? 1 : ai == bi ? 0 : -1;
}

int main(void) {
    int r = 0;
    fgets(s, 32500, stdin);
    for (int i = 0; s[i]; i++) {
        if (isupper(s[i])) cnt[s[i] - 'A']++;
        else if (islower(s[i])) cnt[s[i] - 'a']++;
    }
    qsort(cnt, 26, sizeof(int), cmp1);
    for (int i = 0; i < 26; i++) {
        r += (morse[i] + 3) * cnt[i];
    }
    r -= 3;
    printf("%d", r);
    return 0;
}