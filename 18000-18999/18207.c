#include <stdio.h>

/*
문제 : N(N <= 200000)개의 자연수(<= 10^9)로 이루어진 배열이 주어진다.
이때, 이 배열에서 연속된 길이 2 이상의 구간 가운데 이루는 자연수의 합과 곱이 같은 것의 개수를 구한다.

해결 방법 : 배열에서 연속된 1들을 전부 지운다면 각 지점에서 곱이 전체 합을 넘어가는 지점에서
끊어서 O(Nlog(sum)) 시간 내에 들어올 수 있다. 1들을 지울 수는 없으므로 연속된 1들을 동시에 확인한다.
다음 1이 아닌 수로 이동하면서 곱이 합과 합 + (연속된 1의 개수) 사이 범위에 있으면
그러한 횟수를 전부 세 나가면 된다. 그리고 합에 연속된 1들을 더하고 다음 1이 아닌 수로
넘어가는 것을 반복한다. 이때 곱이 전체 합을 넘어가는지 확인하는 과정에서 오버플로가 날 수 있으므로
나눗셈으로 계산해준다.

주요 알고리즘 : 수학, 백트래킹

출처 : MidC 2019 J번
*/

int a[204800], nn1[204800];

int main(void) {
    int n;
    long long sa = 0, m, s, r = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
        sa += a[i];
    }
    for (int i = n; i >= 0; i--) {
        if (a[i] == 1) continue;
        for (int j = i - 1; j >= 0; j--) {
            nn1[j] = i;
            if (a[j] != 1) break;
        }
    }
    for (int i = 0; i < n; i++) {
        m = 1, s = 0;
        for (int j = i; j < n; j = nn1[j]) {
            if (sa / a[j] < m) break;
            m *= a[j];
            s += a[j];
            if (j > i && s <= m && m <= s + nn1[j] - j - 1) r++;
            s += nn1[j] - j - 1;
        }
    }
    printf("%lld", r);
    return 0;
}