#include <stdio.h>

/*
문제 : 길이 N(N <= 100)의 2020 이하의 자연수로 이루어진 배열이 주어질 때, 이 배열의 연속한 원소 가운데
단조 증가하는 가장 긴 연속한 구간의 길이를 구한다.

해결 방법 : 배열의 원소를 확인할 때 마다 계속해서 단조 증가하는 지 확인하면서 단조 증가하는 경우
그 개수를 1씩 늘려나간다. 그렇지 않다면 최댓값을 갱신하고 길이를 1로 초기화한다.
배열의 끝을 만나면 최댓값을 다시 갱신한 후 최댓값을 출력하면 된다.

주요 알고리즘 : 구현

출처 : JOI 2020예1 3-3번
*/

int a[2048];

int main(void) {
    int n, c = 1, r = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i < n; i++) {
        if (a[i] >= a[i - 1]) c++;
        else {
            if (c > r) r = c;
            c = 1;
        }
    }
    if (c > r) r = c;
    printf("%d\n", r);
    return 0;
}