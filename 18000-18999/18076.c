#include <stdio.h>

/*
문제 : N(N <= 500)개의 정점으로 이루어진 그래프가 있다. 각 정점 쌍마다 간선은 최대 1개이며,
정점 번호가 커지는 순으로만 간선이 이어진다. 이때, 각 정점 쌍마다 경로의 개수의 마지막 자리가 주어지면,
원래의 그래프를 복원한다.

해결 방법 : 먼저 인접한 정점 쌍부터 간선의 여부를 확인한다. 이는 무조건 간선의 수가 0개 또는 1개일 것이므로
간단히 해결 가능하다. 그 다음으로는 정점의 거리를 점점 늘려가며 해당 간선이 없을 때 경로의 수를 세고,
그 값의 마지막 자리가 주어진 값과 같다면 간선이 없는 것이고 1을 더해야 같다면 간선이 있는 것임을 알 수 있다.
경로의 수는 출발 정점에서 이동 가능한 정점들의 경로의 수의 합과 같다.
이를 반복하여 모든 정점 쌍에 대해 간선의 여부를 찾고 이를 출력하면 된다.

주요 알고리즘 : 그래프 이론, 조합론, DP

출처 : NWRRC 2019 J번
*/

char jog[512][512], res[512][512];

int main(void) {
    int n, cnt;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", jog[i]);
        for (int j = 0; j < n; j++) {
            if (j <= i + 1) res[i][j] = jog[i][j];
            else res[i][j] = '0';
        }
    }

    for (int i = 2; i < n; i++) {
        for (int j = 0; j < n - i; j++) {
            cnt = 0;
            for (int k = j + 1; k < j + i; k++) {
                if (res[j][k] == '1') cnt += (jog[k][j + i] - '0');
            }
            cnt %= 10;
            if ((cnt + 1) % 10 + '0' == jog[j][j + i]) res[j][j + i] = '1';
            else if (cnt + '0' == jog[j][j + i]) res[j][j + i] = '0';
            else return 1;
        }
    }
    for (int i = 0; i < n; i++) {
        printf("%s\n", res[i]);
    }
    return 0;
}