#include <stdio.h>
#define DIV 1000000007

/*
문제 : 건물들 사이의 연결 상태가 미리 주어진다. 이 때 단위 시간마다 건물을 계속 옮겨다닌다면 한 지점에서 d만큼의 시간이 지날 동안 움직여 같은 자리로 돌아오는 경로의 가짓수를 구한다.

해결 방법 : 한 곳에서 멈춰있을 수 없으므로 k초때의 지역 x에서의 경로의 가짓수는 k - 1초때의 x와 연결된 지역에서의 경로의 가짓수를 전부 더한 것과 같다.
시작시에는(0초) 시작 지점은 1, 나머지는 0이고, 결괏값은 d초때의 시작 지점에서의 가짓수이다.

주요 알고리즘 : 다이나믹 프로그래밍, 그래프 이론
*/

int mem[102400][8]; //0 : 정보과학관, 1 : 전산관, 2 : 미래관, 3 : 신양관, 4 : 한경직기념관, 5 : 진리관, 6 : 학생회관, 7 : 형남공학관

int main(void) {
     int d;
     scanf("%d", &d);
     mem[0][0] = 1;
     for (int i = 1; i <= d; i++) {
          mem[i][0] = (mem[i - 1][1] + mem[i - 1][2]) % DIV;
          mem[i][1] = ((mem[i - 1][0] + mem[i - 1][2]) % DIV + mem[i - 1][3]) % DIV;
          mem[i][2] = ((mem[i - 1][0] + mem[i - 1][1]) % DIV + (mem[i - 1][3] + mem[i - 1][4]) % DIV) % DIV;
          mem[i][3] = ((mem[i - 1][1] + mem[i - 1][2]) % DIV + (mem[i - 1][4] + mem[i - 1][5]) % DIV) % DIV;
          mem[i][4] = ((mem[i - 1][2] + mem[i - 1][3]) % DIV + (mem[i - 1][5] + mem[i - 1][7]) % DIV) % DIV;
          mem[i][5] = ((mem[i - 1][3] + mem[i - 1][4]) % DIV + mem[i - 1][6]) % DIV;
          mem[i][6] = (mem[i - 1][5] + mem[i - 1][7]) % DIV;
          mem[i][7] = (mem[i - 1][4] + mem[i - 1][6]) % DIV;
     }
     printf("%d", mem[d][0]);
     return 0;
}