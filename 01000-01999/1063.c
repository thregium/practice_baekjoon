#include <stdio.h>
#include <string.h>

/*
문제 : 체스판 위에 돌 두개가 있다. 이 중 한 돌을 움직인 과정이 주어질 때,
이동이 끝난 후 두 돌의 위치를 출력한다. 돌을 움직이며 두 돌이 같은 위치에 있게 되면 다른 돌을 밀어낸다.
이때 돌을 밀어내며 체스판 밖으로 나가는 이동이 생기는 경우 무시한다.

해결 방법 : 돌의 움직임을 입력받은 후 돌이 움직일 때 마다 돌의 움직인 방향을 시뮬레이션 한다.
돌이 다른 돌을 밀어내는 상황의 처리에 주의한다.

주요 알고리즘 : 구현, 시뮬레이션
*/

char ki[4], si[4], m[4];
char* mv[8] = {"R", "L", "B", "T", "RT", "LT", "RB", "LB"}; //이동 방향이 알파벳으로 주어진다.
int k[2], s[2];
int dxy[8][2] = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}, {1, 1}, {-1, 1}, {1, -1}, {-1, -1}}; //각 방향별 xy값 변화

int main(void) {
	int n, mn, r;
	scanf("%s %s %d", ki, si, &n); //두 돌의 좌표가 알파벳+숫자 형태로 주어진다.
	k[0] = ki[0] - 'A';
	s[0] = si[0] - 'A';
	k[1] = ki[1] - '1';
	s[1] = si[1] - '1';
	for(int i = 0; i < n; i++) {
		scanf("%s", m);
		mn = 0;
		for(int j = 0; j < 8; j++) {
			if(!strcmp(m, mv[j])) mn = j;
		}
		if(k[0] + dxy[mn][0] >= 0 && k[0] + dxy[mn][0] < 8 && k[1] + dxy[mn][1] >= 0 && k[1] + dxy[mn][1] < 8) {
			//움직인 돌이 밖으로 나가지 않는 경우
			k[0] += dxy[mn][0];
			k[1] += dxy[mn][1];
			if(k[0] == s[0] && k[1] == s[1]) {
				//움직인 돌이 다른 돌을 밀어내는 경우
				if(s[0] + dxy[mn][0] >= 0 && s[0] + dxy[mn][0] < 8 && s[1] + dxy[mn][1] >= 0 && s[1] + dxy[mn][1] < 8) {
					//다른 돌이 밖으로 나가지 않는 경우
					s[0] += dxy[mn][0];
					s[1] += dxy[mn][1];
				}
				else {
					//다른 돌이 밖으로 나가는 경우 움직임을 취소한다.
					k[0] -= dxy[mn][0];
					k[1] -= dxy[mn][1];
				}
			}
		}
		//printf("%d\n", mn);
	}
	printf("%c%c\n%c%c", k[0] + 'A', k[1] + '1', s[0] + 'A', s[1] + '1');
	return 0;
}
