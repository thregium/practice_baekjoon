#include <stdio.h>

/*
문제 : 검은 색 또는 흰 색으로 각 칸들이 칠해진 M * N 크기의 보드 가운데 (M, N < 50)
8칸을 적절히 잘라서 체스 판을 만들 때 다시 칠해야 하는 칸의 수가 최소가 될 때의 칸수를 구한다.

해결 방법 : 브루트 포스를 통해 모든 가능한 8 * 8 크기에 대해 조사해본다.
체스판은 행과 열 번호의 합이 홀수인 경우와 짝수인 경우가 서로 다른 색이다.
따라서, 이 두 경우에 대해서 각 색의 수를 센 다음, 왼쪽 위가 흰색 또는 검은 색 중 색을 덜 칠하는 방향으로 결정한다.
모든 칸을 조사한 다음 지금까지 확인한 값들 가운데 가장 작은 값을 출력한다.

주요 알고리즘 : 브루트 포스, 구현
*/

int main(void) {
    int n, m, x, y, r = 64;
    char b[64][64];
    scanf("%d %d", &n, &m);
    for(int i = 0; i < n; i++) scanf("%s", b[i]);
    for(int i = 0; i < n - 7; i++) {
        for(int j = 0; j < m - 7; j++) {
			//각 구간을 조사
            x = 0;
            y = 0;
            for(int k = 0; k < 8; k++) {
                for(int l = 0; l < 8; l++) {
                    if((k + l) % 2) {
						//홀수인 경우
                        if(b[i + k][j + l] == 'B') x++;
                        else y++;
                    }
                    else {
						//짝수인 경우
                        if(b[i + k][j + l] == 'W') x++;
                        else y++;
                    }
                }
            }
            if((x < y ? x : y) < r) r = (x < y ? x : y);
			//왼쪽 위가 검은색, 흰색 중 더 값이 작은 것을 최솟값과 비교한다.
        }
    }
    printf("%d", r);
    return 0;
}