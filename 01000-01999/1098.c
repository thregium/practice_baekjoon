#include <stdio.h>
#include <stdlib.h>

/*
문제 : 좌표평면상에 N(N <= 10)개의 마을의 위치(<= 1000, 자연수)가 주어진다. 각 마을은 최대 P(P <= 3)개의 쌍둥이 마을을
둘 수 있고, 각 쌍둥이 마을과의 거리는 D(D <= 2000) 이상이 되어야 한다. 이때, 만들 수 있는 쌍둥이 마을의
최대 개수와, 그 가운데 쌍둥이 마을간의 최소 거리 합을 구한다.

해결 방법 : 각 마을의 설정된 쌍둥이 마을 수를 각 숫자로 하여 N자리 P + 1진법 수로 비트마스킹 DP를 한다.
가능한 각 연결별로 비트마스킹 순서대로 가장 점수(쌍둥이 마을 수 * 큰 수 - 거리 합)가 높은 것을 구해나가면 된다.
모든 연결이 끝난 후 비트마스킹 값 중 가장 높은 것을 찾으면 답이 된다.

주요 알고리즘 : DP, 비트DP

출처 : SRM 430 D1B
*/

char check[1048576];
int mem[1048576], pos[16][2], bx[16];

int big(int a, int b) {
    return a > b ? a : b;
}

int main(void) {
    int n, p, d, cnt, res, dist;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &pos[i][0], &pos[i][1]);
    }
    scanf("%d %d", &p, &d);
    bx[0] = 1;
    for (int i = 1; i <= n; i++) bx[i] = bx[i - 1] * (p + 1); //P + 1의 거듭제곱 미리 계산

    mem[0] = 65535;
    for (int i = 0; i < bx[n]; i++) {
        cnt = 0;
        for (int j = 0; j < n; j++) cnt += i / bx[j] % (p + 1);
        if (cnt & 1) check[i] = 1; //나올 수 없는 경우(홀수개 연결된 경우) 미리 체크
    }

    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            dist = abs(pos[i][0] - pos[j][0]) + abs(pos[i][1] - pos[j][1]);
            if (dist < d) continue;
            for (int k = bx[n] - 1; k >= 0; k--) {
                //중복 방문을 막기 위해 역방향으로 탐색할것
                if (check[k] || !mem[k]) continue; //나올 수 없는 경우 또는 의미 없는 경우를 제외함
                if (k / bx[i] % (p + 1) == p || k / bx[j] % (p + 1) == p) continue; //둘 중 하나 이상이 연결을 다 쓴 경우
                mem[k + bx[i] + bx[j]] = big(mem[k + bx[i] + bx[j]],
                    mem[k] + 65536 - dist); //그 외에는 최댓값 갱신
            }
        }
    }
    res = 0;
    for (int i = 0; i < bx[n]; i++) {
        if (mem[i] > res) res = mem[i]; //그 중 가장 점수가 높은 것 구하기
    }
    printf("%d %d", res >> 16, 65535 - (res & 65535)); //점수를 쌍둥이 마을 수와 거리로 분해해 출력함
    return 0;
}

/*
TC 목록

10
0 0
1 1
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 9
3 10
답: 12 140

10
899 397
2 498
726 773
102 605
721 225
243 263
650 151
40 533
707 205
487 6
3 1
답: 15 5475

10
179 687
982 520
665 168
729 226
194 303
113 616
249 752
751 748
701 800
527 24
3 1
답: 15 5592

10
0 498
492 993
660 157
814 315
256 750
886 379
901 399
661 831
199 700
983 519
3 678
답: 13 12607

10
89 240
269 492
914 286
961 836
768 14
365 421
592 94
250 21
566 438
87 9
2 737
답: 7 6149

10
229 359
160 641
799 574
20 689
687 727
441 740
10 14
474 969
220 144
947 835
1 1498
답: 1 1758

10
1 1
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
3 10
답: 0 0

10
0 0
400 0
800 0
1000 200
1000 600
1000 1000
600 1000
200 1000
0 800
0 400
3 801
답: 15 18800

9
0 1
0 2
0 3
0 4
0 5
0 6
0 7
0 8
0 9
3 6
답: 6 40

9
0 1
0 2
0 3
0 4
0 5
0 6
0 7
0 8
0 9
3 1
답: 13 20
*/