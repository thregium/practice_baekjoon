#include <stdio.h>

/*
문제 : 음이 아닌 정수 구간 [L, R](L, R <= 10^9)의 모든 자연수에서 나오는 숫자의 합을 구한다. 수 앞에 붙는 0은 전부 제거한다.

해결 방법 : 0부터 R까지의 합에서 0부터 L - 1까지의 합을 뺀 값을 구하면 된다. 음수가 나오면 0으로 처리한다.
그 외의 경우는 맨 앞자리부터 살펴보며 해당 자리의 뒤, 해당 자리의 앞, 해당 자리를 각각 나누어 세준다.
맨 앞에 0이 붙을 수 없으므로 처음 살펴보는 경우에는 0에 대한 처리도 해 주어야 한다.

주요 알고리즘 : 수학

출처 : SRM 311 D1B
*/

long long cnt[10];
int digits[10], b10[10];
char ld[10];

long long getsum(int n) {
    if (n < 0) return 0; //음수인 경우에는 0으로 처리한다.
    long long cnt[10] = { 0, };
    long long r = 0, x = 0, d = 0;
    for (int i = 9; i >= 0; i--) {
        //10억의 자리부터 내려가며 확인한다.
        while (x + b10[i] <= n) {
            //10^i를 더해가며 N보다 커지기 전까지 반복한다.
            for (int j = 0; i > 0 && j < 10; j++) {
                cnt[j] += b10[i - 1] * (long long)i; //10^i 뒤에 붙는 수들을 세준다. 단, i가 0인 경우에는 무시한다.
            }
            for (int j = 0; j < d; j++) {
                cnt[ld[j]] += b10[i]; //10^i 앞쪽의 수들을 세준다. 역시 맨 앞 자리라면 무시한다.
            }
            if (d || (x / b10[i])) cnt[x / b10[i] % 10] += b10[i] - 1; //10^i의 수들을 세준다. 맨 앞의 0인 경우는 제외한다.
            else {
                //맨 앞 자리에 첫 번째 자리수가 0인 경우에는 뒤쪽 0을 제거해준다.
                for (int j = i - 1; j >= 0; j--) {
                    cnt[0] -= b10[j] - 1;
                }
            }
            x += b10[i]; //10^i를 더한다.
            cnt[x / b10[i] % 10]++; //자릿수가 넘어갔을 때의 10^i를 세준다.
        }
        if (n / b10[i]) {
            //수가 남는 경우
            ld[d] = n / b10[i] % 10; //앞의 자리들에 수를 추가한다.
            d++;
        }
    }
    for (int i = 0; i < 10; i++) r += cnt[i] * i;
    return r;
}

int main(void) {
    int x = 0, d = 0, l, u;
    b10[0] = 1;
    for (int i = 1; i < 10; i++) {
        b10[i] = b10[i - 1] * 10;
    }
    scanf("%d %d", &l, &u);
    printf("%lld", getsum(u) - getsum(l - 1)); //누적 합을 이용해 0부터의 합으로 바꾸어 계산한다.
    return 0;
}