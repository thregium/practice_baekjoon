#include <stdio.h>

/*
문제 : 3000자 이하의 숫자로 구성된 문자열이 주어질 때, 1부터 N까지의 자연수를 차례로 적은 문자열에서
일부 문자를 지워(또는 지우지 않고) 주어진 문자열을 만들 수 있는 가장 작은 N의 값을 구한다.

해결 방법 : 모든 숫자는 10번마다 반복되기 때문에 N이 많아야 30000 이하에서 나온다는 것을 알 수 있고,
따라서 1부터 차례로 수들을 확인해 나가도 시간 내에 풀 수 있다.
각 수들을 문자열 형태로 바꾼 다음, 수들을 주어진 문자열의 앞에서부터 비교해 나간다. 일치한다면
주어진 문자열의 확인 위치를 다음 칸으로 옮기고, 이를 문자열이 끝날 때 까지 반복해 나간다.
이는 문자가 일치하면 가능한 빠르게 그 문자를 확인하는 것이 가장 좋은 방법이기 때문이다.

주요 알고리즘 : 그리디 알고리즘, 브루트 포스
*/

char s[3072], tmp[16];

void swap(char* a, char* b) {
    char c = *a;
    *a = *b;
    *b = c;
}

int main(void) {
    int p = 0, l;
    scanf("%s", s);
    for (int i = 1;; i++) {
        l = 0;
        for (int j = i; j; j /= 10) tmp[l++] = j % 10 + '0';
        for (int s = 0, e = l - 1; s < e; s++, e--) swap(&tmp[s], &tmp[e]);
        for (int j = 0; j < l; j++) {
            if (tmp[j] == s[p]) p++;
            if (!s[p]) {
                printf("%d", i);
                return 0;
            }
        }
    }
    return 0;
}