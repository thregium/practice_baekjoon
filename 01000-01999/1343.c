#include <stdio.h>

/*
문제 : 50 이하의 'X'와 '.'으로 이루어진 문자열이 주어진다. 이때, 연속된 4개의 'X'를 'A'로 바꾸거나
연속된 2개의 'X'를 'B'로 바꿀 수 있다면 모든 'X'를 바꿀 수 있는지 구하고,
가능하다면 그 방법 가운데 사전 순으로 가장 앞서는 것을 출력한다.

해결 방법 : 'X'를 'A'로 바꿀 수 있는 경우는 항상 'B'로 2번 바꾸어 똑같은 영역을 바꿀 수 있다는 것을 알 수 있다.
따라서, 먼저 'A'로 바꾸어 본 다음 'B'로 바꾸어 보면 바꿀 수 있는 경우에 대해서는 항상 사전 순으로
앞서는 것을 찾을 수 있다. 찾을 때에는 앞 부분부터 바꾸어 나가면 바꿀 수 있는 경우도 항상 찾을 수 있다.

주요 알고리즘 : 그리디 알고리즘
*/

char s[64];

int main(void) {
    int r = 1;
    scanf("%s", s);
    for (int i = 0; s[i]; i++) {
        if (s[i] == 'X' && s[i + 1] == 'X' && s[i + 2] == 'X' && s[i + 3] == 'X') {
            s[i] = 'A', s[i + 1] = 'A', s[i + 2] = 'A', s[i + 3] = 'A';
        }
        else if (s[i] == 'X' && s[i + 1] == 'X') {
            s[i] = 'B', s[i + 1] = 'B';
        }
        else if (s[i] == 'X') r = 0;
    }
    if (r == 0) printf("-1");
    else printf("%s", s);
    return 0;
}