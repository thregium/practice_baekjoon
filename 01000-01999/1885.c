#include <stdio.h>

/*
문제 : 길이 N(N <= 100000)의 K(K <= 10000) 이하 자연수로 이루어진 수열이 주어지면,
K 이하의 자연수로 이루어진 수열 가운데 이 수열의 부분수열이 아닌 가장 짧은 수열의 길이를 구한다.

해결 방법 : 현재 글자까지를 생각했을 때 가장 늦게 나오는 다음 글자를 다음 글자로 한다.
그러한 글자가 없는 경우 탐색을 종료하고 현재까지의 글자 수 + 1을 답으로 하면 된다.
각 글자까지 탐색한 후에는 글자의 체크 여부를 리셋하되 O(N)이 보장되도록 앞에 확인했던 글자부터
현재까지의 글자들만 지우도록 한다. 체크 여부가 리셋되기 때문에 가능한 늦게 나오는 글자를 고르는 것이
최적이 된다.

주요 알고리즘 : 그리디 알고리즘
*/

int s[103000], cnt[10240];

int main(void) {
    int n, k, last = -1, res = 1, rem;
    scanf("%d %d", &n, &k);
    rem = k;
    for (int i = 0; i < n; i++) {
        scanf("%d", &s[i]);
    }
    for (int i = 0; i < n; i++) {
        if (cnt[s[i]] == 0) {
            rem--;
            cnt[s[i]] = 1;
            if (rem == 0) {
                rem = k;
                for (int j = last + 1; j <= i; j++) cnt[s[j]] = 0;
                res++;
                last = i;
            }
        }
    }
    printf("%d", res);
    return 0;
}