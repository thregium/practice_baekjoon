#include <stdio.h>
#include <string.h>

/*
문제 : N(N <= 50)개의 소문자로 이루어진 길이 50 이하 문자열이 주어진다. 이때, 시계방향으로 시프트해서 같아지는 문자열을
같은 문자열이라고 할 때, 서로 다른 문자열의 개수를 구한다.

해결 방법 : 각 문자열을 입력받은 다음, 앞쪽의 문자열에서 같은 문자열을 찾는다.
같은 문자열인 경우는 길이가 같은 경우일 때이다. 여기서 길이가 같으므로 길이의 범위 내에서 1칸씩 밀어보며
일치하는지 확인한 다음, 같은 문자열이 있다면 탐색을 종료하고 다음 문자열을 찾으면 된다.
같은 문자열이 없다면 결괏값에 1을 더하고 다음 문자열을 찾는다. 모든 문자열을 살펴본 다음의 결과값을 출력하면 답이 된다.

주요 알고리즘 : 구현, 문자열, 브루트 포스
*/

char word[64][64];

int main(void) {
    int n, l, cy, ok, r = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", word[i]);
    }
    for (int i = 0; i < n; i++) {
        cy = 0;
        for (int j = 0; j < i; j++) {
            if (strlen(word[i]) != strlen(word[j])) continue; //길이가 다르다면 같은 문자열이 아니다.
            //길이가 서로 같은 이전의 모든 문자열을 살핀다.
            l = strlen(word[i]);
            for (int k = 0; k < l; k++) {
                ok = 1;
                //1칸씩 밀어본다.
                for (int p = 0; p < l; p++) {
                    if (word[i][p] != word[j][(k + p) % l]) ok = 0; //밀었을 때 다른 문자가 나오면 다른 문자열이다.
                }
                if (ok) {
                    cy = 1;
                    break;
                }
            }
            if (cy) break;
        }
        r += (!cy); //같은 문자열이 아니라면 결괏값에 1을 더한다.
    }
    printf("%d", r);
    return 0;
}