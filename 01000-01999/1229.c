#include <stdio.h>

/*
문제 : 자연수 N(N <= 10^6)이 주어질 때, 이 수를 가장 적은 개수의 육각수 합으로 나타내는 방법의 육각수 개수를 구한다.
단, 146859 이상에서는 답이 최대 3, 131 이상에서는 최대 4, 27 이상에서는 최대 5이고, 답이 6인 경우는 11과 26뿐이다.

해결 방법 : 10^6 이하인 육각수의 개수는 707개, 146858 이하인 육각수는 271, 130 이하에서는 8, 26 이하에서는 3개이다.
각각은 제곱, 세제곱, 네제곱, 다섯제곱 하더라도 충분히 시간 내에 풀 수 있는 크기기 때문에
각 수들을 경우를 나누어 답이 각각 2, 3, 4, 5 이하인지 확인해보면 된다.

주요 알고리즘 : 브루트 포스, 케이스 워크
*/

int bb[103000];
int bbs = 0;
//707, 271, 8(30), 3

int main(void) {
    int t = 1, a = 5, n, r = -1;
    for (; t <= 1000000; bbs++) {
        bb[bbs] = t;
        t += a;
        a += 4;
    }
    scanf("%d", &n);
    if (n == 11 || n == 26) {
        printf("6");
        return 0;
    }
    if (n > 146858) {
        r = 3;
        for (int i1 = 0; i1 < 707; i1++) {
            if (r > 1 && bb[i1] == n) r = 1;
            for (int i2 = 0; i2 < 707; i2++) {
                if (r > 2 && bb[i1] + bb[i2] == n) r = 2;
            }
        }
    }
    else if (n > 1791) {
        r = 4;
        for (int i1 = 0; i1 < 271; i1++) {
            if (r > 1 && bb[i1] == n) r = 1;
            for (int i2 = 0; i2 < 271; i2++) {
                if (r > 2 && bb[i1] + bb[i2] == n) r = 2;
                for (int i3 = 0; i3 < 271; i3++) {
                    if (r > 3 && bb[i1] + bb[i2] + bb[i3] == n) r = 3;
                }
            }
        }
    }
    else {
        r = 5;
        for (int i1 = 0; i1 < 30; i1++) {
            if (r > 1 && bb[i1] == n) r = 1;
            for (int i2 = 0; i2 < 30; i2++) {
                if (r > 2 && bb[i1] + bb[i2] == n) r = 2;
                for (int i3 = 0; i3 < 30; i3++) {
                    if (r > 3 && bb[i1] + bb[i2] + bb[i3] == n) r = 3;
                    for (int i4 = 0; i4 < 30; i4++) {
                        if (r > 4 && bb[i1] + bb[i2] + bb[i3] + bb[i4] == n) r = 4;
                    }
                }
            }
        }
    }
    if (r < 0) return 1;
    printf("%d", r);
    return 0;
}