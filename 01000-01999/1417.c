#include <stdio.h>

/*
문제 : N(N <= 50)명의 후보와 각 후보의 투표수(<= 100)가 주어질 때,
1번 후보가 당선되기 위해 바꾸어야 할 표의 최소 개수를 구한다. 단, 동표인 후보가 없이 단독 1등인 경우만 당선된다.

해결 방법 : 투표 수와 N이 크지 않으므로 직접 투표를 바꾸어가며 바꿀 표의 개수를 알아본다.
바꾸어야 할 표는 현재 1위(단독 또는 공동)인 후보의 표이다. 공동 1위인 후보가 여럿 있다면 그 중 아무나 고른다.
그 후보의 표를 골라 1번 후보의 표에 추가한다. 그 다음 1위 후보를 찾는 것을 반복하다가 1위 후보가 당선될 때
그때까지 바꾼 표의 개수를 출력하면 된다.

주요 알고리즘 : 그리디 알고리즘, 시뮬레이션
*/

int vote[64];

int main(void) {
    int n, best, bv, r = 0;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &vote[i]);
    }
    if (n == 1) {
        printf("0");
        return 0;
    }
    while (1) {
        bv = -1, best = -1;
        for (int i = 2; i <= n; i++) {
            if (vote[i] > bv) {
                bv = vote[i];
                best = i;
            }
        }
        if (best < 0) return 1;
        if (bv < vote[1]) break; //당선 조건을 충족시켰을 때
        else {
            vote[best]--; //다른 후보 가운데 1위인 후보의 표를 1번 후보의 표로 바꾼다.
            vote[1]++;
        }
        r++;
    }
    printf("%d", r);
    return 0;
}