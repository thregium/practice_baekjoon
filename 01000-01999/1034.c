#include <stdio.h>

/*
문제 : N * M(N, M <= 50) 칸의 격자에 램프들이 있다. 이 램프들에 대해 K(K <= 1000)번 열의 램프들의 상태를 반전시킨다면
가장 많은 행이 켜져있을 때의 켜진 행의 수를 구한다.

해결 방법 : 켜져 있을 수 있는 행들을 생각한다. 만약 두 행이 서로 다르다면 절대 같이 켜져 있을 수 없다.
따라서, 각 행들을 한번씩 살펴보며 같은 행의 수를 찾은 다음 K번에 킬 수 있는지만 확인해보면 된다.
K번에 킬 수 있는지는 0의 개수를 통해 알아낼 수 있다. 만약 0이 K보다 많다면 절대 켤 수 없다.
K 이하라면 K - (0의 개수)가 홀수인 경우에는 켤 수 없고 짝수 또는 0인 경우 켤 수 있다.
답은 켤 수 있는 행들 가운데 같은 행이 가장 많은 행의 행 수가 된다.

주요 알고리즘 : 애드 혹?
*/

char lamp[64][64];

int main(void) {
    int n, m, k, r = 0, t, c, d; //r : 결괏값, t : 임시 값(열의 동일 여부 검사), c : 같은 행의 수, d : 0의 개수
    scanf("%d %d", &n, &m);
    for (int i = 0; i < n; i++) {
        scanf("%s", lamp[i]);
    }
    scanf("%d", &k);
    for (int i = 0; i < n; i++) {
        c = 0;
        for (int j = 0; j < n; j++) {
            t = 1;
            for (int ii = 0; ii < m; ii++) {
                if (lamp[i][ii] != lamp[j][ii]) {
                    t = 0;
                    break;
                }
            }
            if (t) c++;
        }
        if (c <= r) continue;
        d = 0;
        for (int j = 0; j < m; j++) {
            if (lamp[i][j] == '0') d++;
        }
        if (d <= k && !((k - d) & 1)) r = c;
    }
    printf("%d", r);
    return 0;
}