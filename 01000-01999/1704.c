#include <stdio.h>

/*
문제 : M * N(M, N <= 15) 격자에 1 또는 0이 있다. 각 칸을 누르면 해당 칸과 상하좌우 4개의 칸의 비트가 반전된다 할 때,
가장 적은 칸을 눌러 모든 비트를 0으로 만드는 방법 가운데 사전순으로 가장 앞선 것을 찾는다.
그러한 것이 없는 경우 IMPOSSIBLE을 출력한다.

해결 방법 : 먼저, 각 칸은 2회 누르면 누르지 않은 것과 같기 때문에 2회 이상 누를 필요는 없다.
또한, 맨 위 행의 누르는 방법을 선택하면 그 이후 행은 위 행을 0으로 만들도록만 비트를 바꾸면 되기 때문에
더 선택을 하지 않아도 된다. 따라서, 맨 위 행을 누르는 2^N가지 방법을 모두 해 본 다음, 모든 비트를 0으로 만드는
방법이 있는지 확인하고 그 방법 가운데 가장 적은 칸을 누르는 것을 찾는다.
그러한 것이 있다면 사전순으로 가장 앞선 것을 찾으면 되는데, 맨 윗 줄을 비트마스킹 순서의 반대 방향으로
만드는 경우에는 먼저 나온 것이 사전순으로 앞선 것이므로 그것을 출력하면 된다.

주요 알고리즘 : 브루트 포스?

출처 : USACO 2007O S3번
*/

int a[16][16], t[16][16];

int main(void) {
    int m, n, r, best = -1, bn = 0401, cnt;
    scanf("%d %d", &m, &n);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &a[i][j]);
        }
    }
    for (int i = 0; i < (1 << n); i++) {
        cnt = 0;
        for (int j = 0; j < n; j++) {
            t[0][n - j - 1] = ((i >> j) & 1); //맨 윗줄 생성(역방향으로)
            cnt += t[0][n - j - 1];
        }
        for (int j = 1; j < m; j++) {
            //이후 줄들은 윗칸을 바탕으로 만들어냄
            for (int k = 0; k < n; k++) {
                if ((a[j - 1][k] + t[j - 1][k] + (j > 1 && t[j - 2][k]) + (k > 0 && t[j - 1][k - 1])
                    + (k < n - 1 && t[j - 1][k + 1])) & 1) {
                    t[j][k] = 1; //윗칸을 0으로 만들기 위해서 눌러야 하는 경우
                    cnt++;
                }
                else t[j][k] = 0;
            }
        }
        r = 1;
        for (int j = 0; j < n; j++) {
            if ((a[m - 1][j] + t[m - 1][j] + (m > 1 && t[m - 2][j]) + (j > 0 && t[m - 1][j - 1])
                + (j < n - 1 && t[m - 1][j + 1])) & 1) r = 0; //맨 밑 줄의 칸이 0이 아닌 경우 실패
        }
        if (r && cnt < bn) {
            best = i; //신기록을 경신한 경우
            bn = cnt;
        }
    }
    if (best < 0) printf("IMPOSSIBLE"); //한 번도 모든 칸을 0으로 만들지 못했을때
    else {
        //모든 칸을 0으로 만들 수 있었다면 그 첫 줄의 값들을 기준으로 나머지 칸들을 만들어낸다.
        for (int i = 0; i < n; i++) {
            t[0][n - i - 1] = ((best >> i) & 1);
        }
        cnt = 0;
        for (int i = 1; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ((a[i - 1][j] + t[i - 1][j] + (i > 1 && t[i - 2][j]) + (j > 0 && t[i - 1][j - 1])
                    + (j < n - 1 && t[i - 1][j + 1])) & 1) {
                    t[i][j] = 1;
                    cnt++;
                }
                else t[i][j] = 0;
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) printf("%d ", t[i][j]);
            printf("\n");
        }
    }
    return 0;
}