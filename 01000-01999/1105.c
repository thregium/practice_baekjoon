#include <stdio.h>

/*
문제 : 구간 [L, R](L <= R <= 2 * 10^9)에서 8의 개수가 가장 적은 수에 있는 8의 개수를 구한다.

해결 방법 : 두 수의 자릿수를 맞춰둔다. 그리고 앞에서부터 자리들을 확인해 나간다. 만약 두 수가 다르다면
그 이후의 수는 모두 8이 아니게 만들 수 있으므로 볼 필요가 없다. 두 수가 같은 경우에는
반드시 해당 구간의 수에는 그 숫자가 들어가게 된다. 그 중 8의 개수를 세만 반드시 들어가는 8의 개수가 되고,
따라서 그 값이 답이 된다.

주요 알고리즘 : 그리디 알고리즘, 수학
*/

int ad[16], bd[16];

int main(void) {
    int a, b, r = 0;
    scanf("%d %d", &a, &b);
    for (int i = 9; i >= 0; i--) {
        ad[i] = a % 10;
        bd[i] = b % 10;
        a /= 10, b /= 10;
    }
    for (int i = 0; i < 10; i++) {
        if (ad[i] == 8 && bd[i] == 8) r++;
        else if (ad[i] != bd[i]) break;
    }
    printf("%d", r);
    return 0;
}