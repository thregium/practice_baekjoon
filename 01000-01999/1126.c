#include <stdio.h>
#define INF 1012345678

/*
문제 : N(N <= 50)개의 자연수가 주어진다. 이때 두 부분집합에 자연수들을 서로 겹치지 않게 나누고 두 부분집합의 합이 같도록 하면
두 부분집합의 합의 크기 중 가장 큰 값을 구한다. 단, 부분집합에 수를 포함하지 않는 것은 가능하고 모든 자연수의 합은 500000 이하이다.

해결 방법 : 저장 배열에 가능한 두 자연수의 차이(+500000) 가운데 가능한 두 탑의 높이 합이 가장 큰 것을 저장한다.
초기 배열에는 0에는 0을 저장하고 나머지 위치들에는 -무한대를 저장한 다음 이후로는 왼쪽에 더하는 경우 -,
오른쪽에 더하는 경우에는 +, 버리는 경우에는 0을 하면서 탑을 쌓는 경우에만 해당 수들에 대해 이번 자연수의 크기만큼을 배열 값에 더해주는 것을 반복한다.
모든 자연수에 대한 시행이 끝나면 0(+500000)의 배열 값에서 2를 나누어주면(양쪽의 합이므로) 결과가 된다.

주요 알고리즘 : DP, 냅색
*/

int a[64], mem[64][1048576];

int big(int a, int b) {
    return a > b ? a : b;
}

int main(void) {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < 1048576; i++) {
        mem[0][i] = -INF;
    }
    mem[0][524288] = 0;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        for (int j = 0; j < 1048576; j++) {
            mem[i][j] = big(mem[i - 1][j], big(j >= a[i] ? mem[i - 1][j - a[i]] + a[i] : -INF, j < 1048576 - a[i] ? mem[i - 1][j + a[i]] + a[i] : -INF));
        }
    }
    printf("%d", mem[n][524288] == 0 ? -1 : (mem[n][524288] >> 1));
    return 0;
}