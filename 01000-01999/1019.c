#include <stdio.h>

/*
문제 : N(N <= 10^9) 이하의 모든 자연수에서 나오는 각 숫자 개수의 합을 구한다. 수 앞에 붙는 0은 전부 제거한다.

해결 방법 : 맨 앞자리부터 살펴보며 해당 자리의 뒤, 해당 자리의 앞, 해당 자리를 각각 나누어 세준다.
맨 앞에 0이 붙을 수 없으므로 처음 살펴보는 경우에는 0에 대한 처리도 해 주어야 한다.

주요 알고리즘 : 수학, 조합론
*/

long long cnt[10];
int digits[10], b10[10];
char ld[10];

int main(void) {
    int n, x = 0, d = 0;
    b10[0] = 1;
    for (int i = 1; i < 10; i++) {
        b10[i] = b10[i - 1] * 10;
    }
    scanf("%d", &n);
    for (int i = 9; i >= 0; i--) {
        //10억의 자리부터 내려가며 확인한다.
        while (x + b10[i] <= n) {
            //10^i를 더해가며 N보다 커지기 전까지 반복한다.
            for (int j = 0; i > 0 && j < 10; j++) {
                cnt[j] += b10[i - 1] * (long long)i; //10^i 뒤에 붙는 수들을 세준다. 단, i가 0인 경우에는 무시한다.
            }
            for (int j = 0; j < d; j++) {
                cnt[ld[j]] += b10[i]; //10^i 앞쪽의 수들을 세준다. 역시 맨 앞 자리라면 무시한다.
            }
            if (d || (x / b10[i])) cnt[x / b10[i] % 10] += b10[i] - 1; //10^i의 수들을 세준다. 맨 앞의 0인 경우는 제외한다.
            else {
                //맨 앞 자리에 첫 번째 자리수가 0인 경우에는 뒤쪽 0을 제거해준다.
                for (int j = i - 1; j >= 0; j--) {
                    cnt[0] -= b10[j] - 1;
                }
            }
            x += b10[i]; //10^i를 더한다.
            cnt[x / b10[i] % 10]++; //자릿수가 넘어갔을 때의 10^i를 세준다.
        }
        if (n / b10[i]) {
            //수가 남는 경우
            ld[d] = n / b10[i] % 10; //앞의 자리들에 수를 추가한다.
            d++;
        }
    }

    for (int i = 0; i < 10; i++) {
        printf("%lld ", cnt[i]); //최종 결과를 출력한다.
    }
    return 0;
}