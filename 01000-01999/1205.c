#include <stdio.h>

/*
문제 : 스코어보드에 P(P <= 50)개의 자리가 있고, 현재 스코어보드에 있는 N(N <= P)개 자리의 점수가 주어진다.
S(S <= 2 * 10^9)점의 점수를 얻었을 때, 스코어보드에 추가될 수 있는지 구하고, 가능하다면 몇 위인지 구한다.
만약 동점자가 나오는 경우는 먼저 추가된 점수를 위쪽에 올리며, 순위는 동 석차 가운데 가장 높은(수로는 작은) 순위로 통일된다.

해결 방법 : 먼저, P와 N이 같은 경우 스코어보드에 추가될 수 있는지 구한다. N위의 점수 이하인 경우
스코어보드에 추가될 수 없다. 스코어보드에 추가될 수 있다면, 몇 위인지 구한다. N등부터 역순으로 살피면서
해당 순위의 점수보다 낮아지는 첫 지점을 확인한다. 그 지점의 순위 + 1(바로 뒷 순위)이 해당 점수의 순위이다.
낮아지는 지점이 없다면 1등인 것이다.

주요 알고리즘 : 구현
*/

int score[64];

int main(void) {
    int n, s, p;
    scanf("%d %d %d", &n, &s, &p);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &score[i]);
    }
    if (n == p && s <= score[n]) {
        printf("-1");
        return 0;
    }
    for (int i = n; i > 0; i--) {
        if (s < score[i]) {
            printf("%d", i + 1);
            return 0;
        }
    }
    printf("1");
    return 0;
}