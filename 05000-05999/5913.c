#include <stdio.h>

/*
문제 : 5 * 5 크기의 격자판에서 N(N <= 22, N은 짝수)개의 주어진 칸을 갈 수 없다고 할 때, (1, 1)과 (5, 5)에서 출발하는
두 같은 길이의 경로가 마지막 한 점에서 만나도록 하는 가짓수를 구한다. 각 경로는 같은 칸을 두 번 지날 수 없고,
두 경로는 마지막 점을 제외하면 서로 만날 수 없다. 각 경로는 상하좌우로만 이동이 가능하다.

해결 방법 : 두 경로의 길이가 같고 마지막 한 점에서만 만난다면 두 경로를 연결한 경로에 따른 두 경로는 유일하게 결정된다.
물론 두 경로에서 연결한 경로 역시 유일하므로 그냥 (1, 1)에서 (5, 5)로 이동하는 경로의 가짓수를 구하면 되고,
이는 백트래킹을 통해 구할 수 있다.

주요 알고리즘 : 브루트 포스, 백트래킹

출처 : USACO 2012J B3번
*/

int vis[8][8];
int dxy[4][2] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };
int res = 0;

void track(int x, int y, int l, int t) {
    if (l == t) {
        if (x == 5 && y == 5) res++;
        return;
    }
    vis[x][y] = 1;
    for (int i = 0; i < 4; i++) {
        if (x + dxy[i][0] >= 1 && x + dxy[i][0] <= 5 && y + dxy[i][1] >= 1 && y + dxy[i][1] <= 5) {
            if (!vis[x + dxy[i][0]][y + dxy[i][1]]) track(x + dxy[i][0], y + dxy[i][1], l, t + 1);
        }
    }
    vis[x][y] = 0;
}

int main(void) {
    int n, x, y;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &x, &y);
        vis[x][y] = 1;
    }
    track(1, 1, 24 - n, 0);
    printf("%d", res);
    return 0;
}