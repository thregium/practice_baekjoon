#include <stdio.h>

/*
문제 : 일렬로 N(N <= 100000)개의 전구가 있다. 각 전구는 켜져있거나 꺼져있는 상태이다.
연속한 임의의 개수의 전구 상태를 반전시키는 것이 가능하다면,
인접한 전구의 색이 다른 가장 긴 구간의 길이를 구한다.

해결 방법 : 인접한 두 전구의 상태가 같은 경우를 1, 다른 경우를 0이라 생각하면,
구간의 합이 2 이하인 가장 긴 구간의 길이 + 1이 답이 된다. 이는 투 포인터 알고리즘으로 구할 수 있다.

주요 알고리즘 : 수학, 투 포인터

출처 : JOI 2013 1번
*/

int a[103000], x[103000];

int main(void) {
    int n, e = 0, c = 0, r = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
        if (i > 0) x[i] = (a[i] ^ a[i - 1]);
    }
    for (int i = 1; i < n; i++) {
        while (e < n && c < 3) {
            if (!x[++e]) c++;
        }
        if (e - i >= r) r = e - i + 1;
        c -= (!x[i]);
    }
    printf("%d\n", r);
    return 0;
}