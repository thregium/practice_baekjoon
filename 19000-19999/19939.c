#include <stdio.h>

/*
문제 : N(N <= 100000)개의 공을 K개의 바구니에 1개 이상 넣으면서 모든 바구니의 공의 개수를 다르게 한다.
이때, 가장 공이 많은 바구니와 적은 바구니의 공의 수를 가능한 적게 한다면 이때의 차이를 구한다. 불가능하다면 -1을 출력한다.

해결 방법 : 먼저, 모든 바구니에 번호(1 ~ K)와 같은 수의 공들을 집어넣는다. 집어넣은 공의 수가 N보다 크다면
바구니에 공을 넣는 것이 불가능하므로 -1을 출력한다. N 이하라면 집어넣은 공의 수가 N이 될 때 까지 다음을 반복한다.
K번 바구니부터 1번 바구니까지 순서대로 공을 하나씩 집어넣는다. 1번 바구니에 집어넣은 다음에는 K번 바구니로 다시 돌아온다.
집어넣은 공의 수가 N이 되면 1번 바구니와 K번 바구니의 공의 개수 차이를 구하면 된다.

주요 알고리즘 : 그리디 알고리즘, 시뮬레이션

출처 : 정올 2020-1 초1/고1번
*/

int balls[1024];

int main(void) {
    int n, k;
    scanf("%d %d", &n, &k);
    for (int i = 0; i < k; i++) {
        balls[i] = i + 1;
        n -= i + 1;
    }
    if (n < 0) {
        printf("-1");
        return 0;
    }
    for (int i = 0; n > 0; i++) {
        balls[k - i % k - 1]++;
        n--;
    }
    printf("%d", balls[k - 1] - balls[0]);
    return 0;
}