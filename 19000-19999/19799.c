#include <stdio.h>

/*
문제 : N(N <= 1000)개의 사과를 M(M <= 1000)명에게 나누어 주려고 한다.
각 사람에게 현재 갖고 있는 사과의 절반을 주거나 반 개의 사과를 준다.
단, 현재 사과가 홀수 개인 경우 반 개의 사과만 줄 수 있다.
최종적으로 남는 사과의 개수로 가능한 개수를 구한다.

해결 방법 : 다이나믹 프로그래밍을 통해 나누어준 사람수마다 남은 사과의 수로 가능한 경우를 구한다.
이때 사과의 수에는 2를 곱한다.(0.5개 단위로 사과가 계산되므로)
최종적으로 M명에게 나누어준 후 가능한 개수들을 모두 찾으면 된다.

주요 알고리즘 : DP

출처 : ROI 2012H E번
*/

char mem[1024][2048];

int main(void) {
    int n, m, res = 0;
    scanf("%d %d", &n, &m);
    n *= 2;
    mem[0][n] = 1;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j <= n; j++) {
            if (j > 0) mem[i + 1][j - 1] |= mem[i][j];
            if (!(j & 1)) mem[i + 1][j >> 1] |= mem[i][j];
        }
    }
    for (int i = 0; i <= n; i++) {
        if (mem[m][i]) res++;
    }
    printf("%d\n", res);
    for (int i = 0; i <= n; i++) {
        if (mem[m][i]) {
            printf("%d.%d ", i >> 1, (i & 1) * 5);
        }
    }
    return 0;
}