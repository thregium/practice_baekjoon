#include <stdio.h>

/*
문제 : N(N <= 10)명이 받은 투표 수(<= 50000)가 주어질 때, 가장 득표를 많이 한 후보가 유일한지 확인하고,
유일하다면 그 후보의 번호와 과반 득표를 했는지 여부를 출력한다.

해결 방법 : 매번 득표 수를 입력받을 때 마다 전체 후보의 득표 수와 가장 많은 득표를 받은 후보의 득표 수,
그러한 후보의 번호를 각각 갱신해나간다. 만약 현재 후보의 득표 수가 최대 득표수보다 많다면
최대 득표수를 현재 득표수로 바꾸고, 후보의 번호도 바꾼다. 만약 최대 득표수와 같다면 후보의 번호를 0으로 바꾸어 둔다.
전체 후보의 득표수는 어떠한 경우든 더해나간다.

모든 후보의 확인이 끝나면 후보의 번호가 0인지 확인한다. 0이라면 최대 득표수인 후보가 2명 이상이라는 의미이므로
그러한 후보가 유일하지 않은 것이다. 0이 아니라면 과반 득표를 확인한다.
해당 후보의 득표 수 * 2와 전체 득표 수를 비교해 전자가 더 많다면 과반 득표를 한 것이고, 그 외에는 하지 못한 것이다.
그리고 해당 후보의 번호를 출력하면 된다.

주요 알고리즘 : 구현

출처 : Rocky 2015 A번
*/

int main(void) {
    int t, n, x, sum, best, bi;
    scanf("%d", &t);
    for (int tt = 0; tt < t; tt++) {
        scanf("%d", &n);
        sum = 0;
        best = -1;
        bi = -1;
        for (int i = 1; i <= n; i++) {
            scanf("%d", &x);
            sum += x;
            if (x > best) {
                bi = i;
                best = x;
            }
            else if (x == best) bi = 0;
        }
        if (bi < 0) return 1;
        if (bi == 0) printf("no winner\n");
        else printf("%s winner %d\n", best * 2 > sum ? "majority" : "minority", bi);
    }
    return 0;
}