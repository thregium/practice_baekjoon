#include <stdio.h>

/*
문제 : 길이 1000 이하의 주어진 형태로 된 문자열이 주어진다. 문자열의 길이는 3의 배수이고, 문자열의 3의 배수 + 1번째 문자는
대문자 'P', 'K', 'H', 'T' 중 하나이다. 그 뒤의 문자 2개는 숫자이고, 수로 바꾸면 1 이상 13 이하가 된다.
이때, 각 문자 3개씩을 카드로 본다면 겹치는 카드가 있는지 확인하고, 겹치지 않는다면 'P', 'K', 'H', 'T'에서 각각
없는 카드의 수를 구한다. 카드 전체 세트는 1에서 13까지 하나씩 있다. 겹치는 경우에는 "GRESKA"를 출력한다.

해결 방법 : 먼저 문자열을 3개씩 읽어가며 카드를 확인한다. 카드의 문양별로 수를 배정하고, 각 문양에서
카드를 수에 따라 배정한 다음 방문 체크를 한다. 만약 이미 체크한 카드인 경우라면 겹치는 카드이므로 "GRESKA"를 출력하면 된다.
그러한 경우가 없이 모든 카드를 확인했다면 전체 세트의 범위에서 문양별로 방문 체크를 하지 않은 카드들의 수를 센 다음
각 문양에 대해 그 값들을 출력하면 된다.

주요 알고리즘 : 구현, 파싱

출처 : COCI 15/16#1 1번
*/

char s[1024];
int cnt[52]; //P: 0, K: 13, H: 26, T: 39

int main(void) {
    int x, r;
    scanf("%s", s);
    for (int i = 0; s[i]; i += 3) {
        if (s[i] == 'P') x = 0;
        else if (s[i] == 'K') x = 13;
        else if (s[i] == 'H') x = 26;
        else if (s[i] == 'T') x = 39;
        else return 2;
        if ((s[i + 1] - '0') * 10 + s[i + 2] - '0' > 13) return 1;
        x += (s[i + 1] - '0') * 10 + s[i + 2] - '0' - 1;
        if (cnt[x]) {
            printf("GRESKA");
            return 0;
        }
        else cnt[x] = 1;
    }
    for (int i = 0; i < 4; i++) {
        r = 0;
        for (int j = 0; j < 13; j++) {
            r += (!cnt[i * 13 + j]);
        }
        printf("%d ", r);
    }
    return 0;
}