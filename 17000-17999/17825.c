#include <stdio.h>

/*
문제 : 문제에서 주어지는 형태의 윷놀이판(생략)과 이에 맞는 규칙에 따라 말 4개를 움직일 때, 주어진 주사위 10개의 값에 따라 나올 수 있는 최고 점수를 구한다.
말들은 주사위의 수만큼 빨간색 화살표를 따라 움직인다. 만약 파란색 화살표가 있는 칸에서 출발했다면 첫 번째 이동은 파란색 화살표를 따라 간다.
말들은 처음에 출발 칸에서 시작한다. 말이 도착 칸에 도달하면 즉시 이동을 멈춘다. 이동은 도착하는 칸에 다른 말이 없는 경우에만 가능하다(도착칸 제외).
주사위는 나온 순서대로 적용한다. 말을 움직인 다음 말이 도착한 칸에 있는 점수를 얻는다.

해결 방법 : 문제의 규칙대로 구현한다.

주요 알고리즘 : 구현, 시뮬레이션, 백트래킹
*/

int pos[4], dices[10];
int nxt[] = { 1, 2, 3, 4, 5, 10, 7, 8, 9, 25, 11, 12, 13, 14, 17, 16, 9, 18, 19, 20, 21, 27, 23, 24, 9, 26, 31, 28, 29, 30, 31, 99 }; //각 칸의 빨간색 화살표가 가리키는 곳
int pts[] = { 0, 2, 4, 6, 8, 10, 13, 16, 19, 25, 12, 14, 16, 18, 20, 22, 24, 22, 24, 26, 28, 30, 28, 27, 26, 30, 35, 32, 34, 36, 38, 40 }; //각 칸의 점수
int best = 0;

int move(int p, int m) {
    //출발 칸에서 이동한 지점을 확인하는 함수
    if (p == 5 || p == 14 || p == 21) {
        p++; //파란색 화살표가 있는 칸에 대한 처리
        m--;
    }
    while (m > 0 && p != 99) {
        p = nxt[p]; //도착 칸에 가기 전까지 다음 칸으로 이동한다.
        m--;
    }
    return p;
}

void track(int n, int turns, int pt) {
    if (n == turns) {
        if (pt > best) best = pt; //10회가 되면 최고점을 업데이트하고 종료한다.
        return;
    }
    int pps, t;

    for (int i = 0; i < 4; i++) {
        pps = pos[i];
        if (pps >= 99) continue; //이미 도착칸에 도달한 경우
        pos[i] = move(pps, dices[turns]);
        t = 1;
        for (int j = 0; j < 4; j++) {
            if (pos[i] == pos[j] && i != j && pos[i] < 99) t = 0; //도착칸이 아닌데 도달한 곳에 다른 말이 있는지 검사한다.
        }
        if (t) track(n, turns + 1, pt + (pos[i] < 99 ? pts[pos[i]] : 0)); //도달한 칸의 점수를 추가하고 다음 주사위를 본다.
        pos[i] = pps; //말의 위치를 복원한다.
    }
}

int main(void) {
    for (int i = 0; i < 10; i++) {
        scanf("%d", &dices[i]);
    }
    track(10, 0, 0);
    printf("%d", best);
    return 0;
}