#include <stdio.h>

/*
문제 : N * M(N, M <= 50) 크기의 직사각형이 일부는 0이나 1로 채워져 있고 일부는 빈 칸일 때, 빈 칸을 채워서 모든 부분 직사각형에
적힌 수의 합이 K(K <= 2500)의 배수가 되게 할 수 있는지 보고, 가능하다면 그러한 경우를 출력한다.

해결 방법 : 먼저, 각 칸들이 부분 직사각형에 몇 회 들어가는지를 계산해 본다. 들어가는 횟수는 (자신과 왼쪽에 있는 칸 수 * 자신과 오른쪽 칸 수)에
(자신과 위쪽 칸 수 * 자신과 아래쪽 칸 수)를 곱한 것과 같다. 그 다음, 이미 선택된 칸들에 대해 (칸에 적힌 수 * 들어가는 횟수의 합) % K를 계산하고,
빈 칸들에 대해서는 들어가는 횟수와 각 칸들의 위치를 기록한다. 위 수를 시작점으로 하여 냅색을 이용하면 K로 나눈 나머지가 X인 경우가 가능할 지를
알 수 있고, 따라서, 모든 칸을 채운 경우 합이 K의 배수인 것이 가능한지(나머지가 0일 수 있는지)도 알 수 있다. 가능하다면, 냅색을 뒤에서부터 살펴보며
이전 칸을 살펴봤을 때 현재 모듈로가 불가능하다면 현재 칸이 1, 아니라면 현재칸이 0이 되도록 칸들을 채우면 된다.

주요 알고리즘 : 다이나믹 프로그래밍, 냅색, 역추적, 수학

출처 : 연세대 2019 D번
*/

int a[64][64], ax[64][64], cells[2560][3], mem[2560][2560];
int cp = 1;

int main(void) {
    int n, m, k, s = 0;
    scanf("%d %d %d", &n, &m, &k);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            scanf("%d", &a[i][j]);
            ax[i][j] = (i + 1) * (n - i) * (j + 1) * (m - j);
            if (a[i][j] < 0) {
                cells[cp][0] = ax[i][j] % k;
                cells[cp][1] = i;
                cells[cp++][2] = j;
            }
            else if (a[i][j]) s = (s + ax[i][j]) % k;
        }
    }
    mem[0][s] = 1;
    for (int i = 1; i < cp; i++) {
        for (int j = 0; j < k; j++) {
            mem[i][j] = mem[i - 1][j] | mem[i - 1][(j + k - cells[i][0]) % k];
        }
    }
    if (!mem[cp - 1][0]) {
        printf("-1");
        return 0;
    }
    printf("1\n");
    s = 0;
    for (int i = cp - 1; i > 0; i--) {
        if (mem[i - 1][s]) {
            a[cells[i][1]][cells[i][2]] = 0;
        }
        else {
            a[cells[i][1]][cells[i][2]] = 1;
            s = (s + k - cells[i][0]) % k;
        }
    }
    s = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%d ", a[i][j]);
            s = (s + ax[i][j] * a[i][j]) % k;
        }
        printf("\n");
    }
    return s;
}