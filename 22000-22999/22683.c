#include <stdio.h>

/*
문제 : 가로 N + 1개 * 세로 M + 1개(N, M <= 1500)의 도로가 있다. 각 가로와 세로 사이
도로의 간격이 주어질 때, 도로 사이에서 찾을 수 있는 정사각형의 개수를 구한다.
도로의 간격은 1000 이하의 자연수이다.

해결 방법 : 각 가로와 세로 사이 간격의 최댓값이 약 150만으로 메모리에 담을 수 있는 정도기 때문에
간격 별로 가로와 세로에서 나오는 횟수를 각각 저장해둔다. 시작점을 1칸씩 늘려가며 누적합을
구하는 것으로 간단하고 빠르게 찾는 것이 가능하다. 그리고 0부터 150만까지 각 크기마다 가로와
세로의 횟수를 곱한 값이 전체 도로에서 찾을 수 있는 그 크기의 정사각형 개수이며,
이를 모두 더하면 답이 된다.

주요 알고리즘 : 수학, 조합론, 누적 합

출처 : JAG 2007D D번
*/

int h[1536], w[1536], cnt[1572864][2];

int main(void) {
    int n, m;
    long long s;
    while (1) {
        scanf("%d %d", &n, &m);
        if (n == 0) break;
        for (int i = 0; i < n; i++) {
            scanf("%d", &h[i]);
        }
        for (int i = 0; i < n; i++) {
            s = 0;
            for (int j = i; j < n; j++) {
                s += h[j];
                cnt[s][0]++;
            }
        }
        for (int i = 0; i < m; i++) {
            scanf("%d", &w[i]);
        }
        for (int i = 0; i < m; i++) {
            s = 0;
            for (int j = i; j < m; j++) {
                s += w[j];
                cnt[s][1]++;
            }
        }
        
        s = 0;
        for (int i = 0; i <= 1500000; i++) {
            s += (long long)cnt[i][0] * cnt[i][1];
            cnt[i][0] = 0, cnt[i][1] = 0;
        }
        printf("%lld\n", s);
    }
    return 0;
}