#include <stdio.h>
#define DIV 9901
/*
문제 : n * m 직사각형을 1 * 2 크기의 직사각형으로 빈틈 없이 채우는 방법의 가짓수를 구한다.

해결 방법 : 전체 직사각형을 칸별로 나누고, 전부 채워진 칸을 기준으로 다음 열의 행별로 비트마스킹을 하여 다이나믹 프로그래밍을 실행한다.
비트마스킹에서 현재 칸에서 채울 수 있는 마지막 칸이 비어있는 경우 이전 칸의 비트마스킹 정보를 1칸씩 옮겨 복사하고, 
차있는 경우에는 이전 칸에서 가로로 놓은 경우의 정보를 추가한다. 그리고 마지막 2칸이 모두 비어있고 현재 칸이 첫 번째 칸이 아닌 경우 2칸 이전 칸에서
세로로 놓은 경우의 정보를 추가한다.
이 과정을 모든 칸을 채울 때 까지 시행한 후 마지막 칸의 비트마스킹이 0인 경우의 정보를 출력한다.

주요 알고리즘 : 다이나믹 프로그래밍, 비트마스킹
*/

int blocks[256][32768]; //i : m번째 칸, j : 각 행의 블록 여부

int main(void) {
    int n, m;
    scanf("%d %d", &n, &m);
    blocks[0][0] = 1;
    for (int i = 1; i <= n * m; i++) {
        for (int j = 0; j < 1 << n; j++) {
            if ((j >> (n - 1)) % 2 == 0) {
                blocks[i][j] = (blocks[i][j] + blocks[i - 1][(j << 1) + 1]) % DIV;
            }
            if ((j >> (n - 1)) % 2 == 1) {
                blocks[i][j] = (blocks[i][j] + blocks[i - 1][(j << 1) % (1 << n)]) % DIV;
            }
            if ((i - 1) % n > 0 && (j >> (n - 2)) % 4 == 0) {
                blocks[i][j] = (blocks[i][j] + blocks[i - 2][j << 2]) % DIV;
            }
        }
    }

    printf("%d", blocks[m * n][0]);
    return 0;
}