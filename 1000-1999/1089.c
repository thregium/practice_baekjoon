#include <stdio.h>

/*
문제 : 전광판의 형태가 주어질 때, 켜져 있는 전구에 다른 전구를 추가로 켜서 만들 수 있는 숫의 기댓값을 구한다.
만들 수 있는 수가 없다면 -1을 출력한다.

해결 방법 : 먼저, 각 수의 형태를 비트마스킹을 통해 미리 계산해놓는다.
전광판을 입력받으면 똑같이 비트마스킹을 통해 가능한 숫자들을 구하고, 구한 숫자들의 평균에 10 ^ (그 자리의 위치)를 해서 기댓값에 더한다.
한번이라도 가능한 숫자가 없는 경우에는 -1을 출력한다.

주요 알고리즘 : 수학, 구현, 문자열, 확률론, 비트마스킹
*/

int nums[10] = { 31599, 4681, 29671, 29647, 23497, 31183, 31215, 29257, 31727, 31695 };
char b[5][64];

int main(void) {
    int n, t, s, c;
    long long d = 1;
    double r = 0;
    scanf("%d", &n);
    for (int i = 0; i < 5; i++) {
        scanf("%s", b[i]);
    }
    for (int i = n - 1; i >= 0; i--) {
        for (int j = 0; j < 5; j++) {
            if (b[j][i * 4 + 3] == '#') r = -1;
        }
        t = 0;
        for (int j = 0; j < 5; j++) {
            for (int k = 0; k < 3; k++) {
                if (b[j][i * 4 + k] == '#') {
                    t += (1 << ((4 - j) * 3 + (2 - k))); //비트마스킹
                    if ((j == 1 && k == 1) || (j == 3 && k == 1)) r = -1;
                }
            }
        }
        if (r < 0) break;
        s = 0;
        c = 0;
        for (int j = 0; j < 10; j++) {
            if ((t | nums[j]) == nums[j]) {
				// 비트마스킹을 통해 or 연산으로 해당 숫자를 만들 수 있는지 간단히 알 수 있다.
                s += j;
                c++;
            }
        }
        r += (double)s / c * d;
        d *= 10;
    }
    if (r < 0) printf("-1");
    else printf("%.10f", r);
    return 0;
}