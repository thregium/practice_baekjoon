#include <stdio.h>

/*
문제 : 'A'와 'B'로만 이루어진 길이 N(N <= 50)의 문자열 가운데 A 뒤에 B가 오는 쌍이 K개인 문자열을 아무거나 하나 출력한다.
없는 경우 -1을 출력한다.

해결 방법 : 먼저, 길이가 N일 때 문자열을 만들 수 있는 가장 큰 K가 되는 경우는 앞쪽에 A가 절반, 뒤쪽에 B가 절반 있는 경우이다.
이때의 K는 N이 짝수일 때 (N / 2)^2, 홀수일 때 ((N - 1) / 2) * ((N + 1) / 2)이다.
따라서, 이보다 큰 경우에는 -1을 출력한다.

문자열을 만들 수 있다면, 우선 쌍이 0개일 때에서 시작한다. 이때는 모든 문자가 'B'인 상태이다.
여기서 'A'를 앞쪽부터 넣어가며 K의 개수를 확인한다. A를 새로 넣어서 추가할 수 있는 K의 개수는 (N - i * 2 + 1)이다.
이 식에서 i는 넣는 A의 번호이다. 그보다 크다면 그 번째에 A를 넣고 K에서 해당 수를 뺀 후 다음 문자를 살핀다.
그 이하인 경우에는 뒤에서부터 셌을 때 넣어야 할 위치에 A를 넣고 탐색을 종료하면 된다. 이때의 위치는 뒤에서 K번째이다.
탐색을 종료하면 지금까지 만든 문자열을 출력한다.

주요 알고리즘 : 그리디 알고리즘, 조합론, 구성적
*/

char res[64];

int main(void) {
    int n, k;
    scanf("%d %d", &n, &k);
    if (k > (n >> 1) * ((n + 1) >> 1)) {
        printf("-1");
        return 0;
    }
    for (int i = 0; i < n; i++) res[i] = 'B';
    for (int i = 1; i <= (n >> 1); i++) {
        if (k > n - i * 2 + 1) {
            k -= n - i * 2 + 1;
            res[i - 1] = 'A';
        }
        else {
            res[n - i - k] = 'A';
            break;
        }
    }
    printf("%s", res);
    return 0;
}