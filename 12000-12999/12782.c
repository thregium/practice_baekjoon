#include <stdio.h>

/*
문제 : 길이 10^6 이하로 같은 길이의 두 이진수가 주어질 때, 첫 번째 이진수에서 두 비트를 바꾸거나
비트를 뒤집는 행동을 최소 몇 회 해야 두 번째 이진수가 되는지 구한다.

해결 방법 : 두 이진수 사이 차이 나는 비트들의 수를 센다. 첫 번째 이진수에서 0인 것과 1인 것은 서로 바꿀 수 있고,
바꾸는 것이 서로 두 번 뒤집는 것보다 유리하므로 해당하는 것을 한 번씩 바꿔주고, 나머지는 뒤집어준다.
이는 서로 다른 비트 가운데 첫 번째 이진수에서 0인 것과 1인 것을 각각 세었을 때 더 많은 것의 개수와 같으므로
그 값을 출력하면 된다.

주요 알고리즘 : 그리디 알고리즘

출처 : 인하대 2016 E번
*/

char a[1048576], b[1048576];
int err[2];

int big(int a, int b) {
	return a > b ? a : b;
}

int main(void) {
	int t;
	scanf("%d", &t);
	for(int tt = 0; tt < t; tt++) {
		scanf("%s %s", a, b);
		err[0] = 0, err[1] = 0;

		for (int i = 0; a[i]; i++) {
			if (a[i] != b[i]) err[a[i] - '0']++;
		}
		printf("%d\n", big(err[0], err[1]));
	}
	return 0;
}