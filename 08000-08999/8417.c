#include <stdio.h>

/*
문제 : 길이 200 이하의 소문자로 이루어진 문자열이 N(N <= 10000)개 주어질 때, 길이 2 이상의 회문 부분 문자열이 있는
문자열의 개수를 구하고, p, b, d와 i, j를 각각 같은 것으로 보았을 때의 길이 2 이상의 해당 문자열의 개수를 구한다.

해결 방법 : 원래 문자열에서 p, b, d를 b로, i, j를 i로 바꾼 문자열을 미리 만든 다음,
길이 2 이상의 회문 부분 문자열을 각각 찾는다. 길이 4 이상의 회문 부분 문자열은 항상 길이 3 이하의 회문 부분 문자열을 포함하므로
길이 2 또는 3인 회문 부분 문자열을 찾으면 되고, 이는 인접한 같은 문자나 1칸 떨어진 같은 문자를 찾는 것으로 확인 가능하다.
이를 이용해 원하는 결괏값을 구해낼 수 있다.

주요 알고리즘 : 문자열, 애드 혹

출처 : PA 2005 1-1번
*/

char s[256], s2[256];

int main(void) {
    int n, r1 = 0, r2 = 0, t;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", s);
        for (int j = 0; j == 0 || s[j - 1]; j++) {
            if (s[j] == '\0') s2[j] = '\0';
            else if (s[j] == 'p' || s[j] == 'd') s2[j] = 'b';
            else if (s[j] == 'j') s2[j] = 'i';
            else s2[j] = s[j];
        }
        t = 0;
        for (int j = 1; s[j]; j++) {
            if (s[j] == s[j - 1]) t = 1;
            else if (j > 1 && s[j] == s[j - 2]) t = 1;
        }
        r1 += t;
        t = 0;
        for (int j = 1; s2[j]; j++) {
            if (s2[j] == s2[j - 1]) t = 1;
            else if (j > 1 && s2[j] == s2[j - 2]) t = 1;
        }
        r2 += t;
    }
    printf("%d\n%d", r1, r2);
    return 0;
}