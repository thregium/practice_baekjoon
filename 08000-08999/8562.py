'''
문제 : D(D <= 500)자리수 N이 주어진다. N을 2^i * (0, 1,-1)의 합으로 나타내려고 할 때,
0이 아닌 수는 최소 몇 개가 필요한지 구한다.

해결 방법 : 먼저 가장 앞 자리를 구한 다음에 뒤로 한칸씩 내려가며
다음 자릿수를 확인해보면 된다. 가장 앞 자릿수는 N 이하의 가장 큰 2의 거듭제곱 또는
N 이상의 가장 작은 2의 거듭제곱 둘 중 하나이다. (그 이상이면 사이 자리를 1 또는 -1로 채워야 하기 때문)
이때, 두 거듭제곱 사이의 값은 대칭이 됨을 알 수 있다.
큰 값 쪽이라면 1, -1이고 작은 값 쪽이라면 1, 1쪽이 된다. 이때 해당 값과의 차이는 작은 값 / 2까지의 값과 같다.
따라서, 두 거듭제곱 가운데 가까운 쪽으로 이동한 후, N을 그 값과의 차로 바꾸는 것을 반복하면 답을 얻을 수 있다.

주요 알고리즘 : 수학, 빅인티저

출처 : PA 2001 3-2번
'''

def small(a, b):
    if(a < b):
        return a
    else:
        return b

d = int(input())
n = int(input())
b2 = 1
r = 0

while b2 <= n:
    b2 *= 2
b2 >>= 1
while n > 0:
    n = small(b2 * 2 - n, n - b2)
    while b2 > n:
        b2 >>= 1
    r += 1

print(r)
