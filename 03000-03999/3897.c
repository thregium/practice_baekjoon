#include <stdio.h>

/*
문제 : 0번부터 N(N <= 100)번까지의 칸으로 이루어진 게임 판이 있다. 이 판에서 0번 칸부터 출발해
주사위를 던질 때 마다 던진 칸 수만큼 이동한다. N번 칸을 넘어가면 넘어간 칸 수만큼 N번에서 뒤로 이동하며,
정확히 N번 칸에 도착하면 이긴다. 중간에 L(L <= N - 1)개의 주어진 칸에 들어가면 1턴 쉬고, B(B <= N - 1)개의
주어진 칸에 들어가면 0번 칸으로 되돌아갈 때, T(T <= 100)턴 안에 게임을 이길 확률을 구한다.

해결 방법 : 다이나믹 프로그래밍을 통해 답을 구할 수 있다. (현재 턴 수, 게임판 위치, 쉬는지 여부)를
변수로 하고, (0, 0, 0)을 1로, 나머지를 0으로 하여 시작한다. 각 턴마다 모든 칸에 대해 쉬는 턴이 아니라면
다음 턴에 도달 가능한 각 위치에 현재 확률의 1/6을 곱한 값을 더한다. 쉬는 턴이라면 같은 칸의
쉬는 턴이 아닌 곳에 현재 값을 그대로 가져오면 된다. 이를 반복하며 N번 칸에 도달한
모든 확률의 합을 더하면 된다.

주요 알고리즘 : DP, 확률론

출처 : Tokyo 2007 C번
*/

int cell[128];
double mem[128][128][2];

int main(void) {
    int n, t, l, b, x;
    double r;
    while (1) {
        scanf("%d %d %d %d", &n, &t, &l, &b);
        if (n == 0) break;
        for (int i = 0; i < l; i++) {
            scanf("%d", &x);
            cell[x] = 1;
        }
        for (int i = 0; i < b; i++) {
            scanf("%d", &x);
            cell[x] = 2;
        }

        r = 0.0;
        mem[0][0][0] = 1.0;
        for (int i = 0; i < t; i++) {
            for (int j = 0; j < n; j++) {
                mem[i + 1][j][0] += mem[i][j][1];
                for (int k = 1; k <= 6; k++) {
                    x = j + k;
                    if (x > n) x = n - (x - n);
                    if (cell[x] == 2) mem[i + 1][0][0] += mem[i][j][0] * 1.0 / 6.0;
                    else if (cell[x] == 1) mem[i + 1][x][1] += mem[i][j][0] * 1.0 / 6.0;
                    else mem[i + 1][x][0] += mem[i][j][0] * 1.0 / 6.0;
                }
            }
            r += mem[i + 1][n][0];
        }
        printf("%.9f\n", r);

        for (int i = 0; i <= t; i++) {
            for (int j = 0; j <= n; j++) {
                mem[i][j][0] = 0.0;
                mem[i][j][1] = 0.0;
            }
        }
        for (int i = 0; i <= n; i++) cell[i] = 0;
    }
    return 0;
}