#include <stdio.h>
#include <stdlib.h>

/*
문제 : 시:분이 HH:MM 형태로 주어질 때, 해당 시:분과 동등한 형태의 시:분(시에 24의 배수를 더하고 분에 60의 배수를 더한 형태)
가운데 가장 드는 노력이 적은(모든 자판 이동의 맨해튼 거리의 합이 가장 작은) 것을 출력한다.
이러한 것이 여럿인 경우 사전순으로 가장 작은(시->분이 가장 작은) 것을 출력한다.

해결 방법 : 각 동등한 시:분을 시->분 순서로 확인해 나간다. 시의 십의 자리-시의 일의 자리의 노력에
시의 일의 자리-분의 십의 자리의 노력과 분의 십의 자리-분의 일의 자리의 노력을 더한 값을 구하고,
이 값이 최댓값보다 작은 경우 최댓값을 갱신하고 결괏값을 바꾸어 나간다.
최종적으로 남는 결괏값이 답이 된다.

주요 알고리즘 : 구현, 브루트 포스

출처 : CHCI 2006RJ 1번
*/

int loc[10][2] = { {3, 1}, {0, 0}, {0, 1}, {0, 2}, {1, 0}, {1, 1}, {1, 2}, {2, 0}, {2, 1}, {2, 2} }; //각 자판의 좌표

int geteff(int a, int b) {
    //두 자판이 주어지면 두 자판 사이를 이동하기 위한 노력량을 출력함
    if (a >= 10 || b >= 10 || a < 0 || b < 0) return -101234567; //오류 확인용
    else return abs(loc[a][0] - loc[b][0]) + abs(loc[a][1] - loc[b][1]);
}

int main(void) {
    int h, m, t, r = -1, best = 999;
    scanf("%d:%d", &h, &m);
    for (int i = 0; h + i * 24 < 100; i++) {
        for (int j = 0; m + j * 60 < 100; j++) {
            t = geteff((h + i * 24) / 10, (h + i * 24) % 10); //시1-시2
            t += geteff((h + i * 24) % 10, (m + j * 60) / 10); //시2-분1
            t += geteff((m + j * 60) / 10, (m + j * 60) % 10); //분1-분2
            if (t < 0) return 1;
            if (t < best) {
                //노력의 합이 더 적은 경우
                r = (h + i * 24) * 100 + (m + j * 60); //4자리 형태로 시:분을 저장
                best = t; //최댓값 갱신
            }
        }
    }
    printf("%02d:%02d", r / 100, r % 100); //시:분 출력
    return 0;
}