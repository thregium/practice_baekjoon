#include <stdio.h>

/*
문제 : W * D(W, D <= 10) 크기의 격자의 각 칸마다 블록을 0개 이상 20개 이하로 쌓았다.
앞과 옆에서 본 블록의 형태가 주어지면 블록을 쌓는 방법 가운데 가장 적게 쌓았을 때의 쌓은 개수를 구한다.
그렇게 쌓는 방법이 없는 경우는 주어지지 않는다.

해결 방법 : 양쪽에서 모두 같은 높이인 칸에는 그 높이로 블록을 쌓으면 양쪽의 조건을 만족한다.
그 외의 경우에는 한쪽의 조건만 충족시킬 수 있고, 다른쪽의 가장 높은 줄과 같은 줄에 쌓으면
일단 안전하게 추가 가능하다. 결국 앞과 옆에서 본 높이 배열에서 서로 겹치는 값들을 최대한 만든 뒤,
그 값들에 거기에 포함되지 않은 나머지 값들을 더하면 답이 된다. 이때 서로 높이가 같은 여러 값이
있는 경우 전부 독립적으로 보아야 함에 유의한다.

주요 알고리즘 : 그리디 알고리즘

출처 : Tokyo 2009 A번
*/

int hw[16], hd[16];

int main(void) {
    int w, d, r;
    while (1) {
        scanf("%d %d", &w, &d);
        if (w == 0) break;
        if (w > 10 || d > 10) return 1;
        r = 0;
        for (int i = 0; i < w; i++) {
            scanf("%d", &hw[i]);
        }
        for (int i = 0; i < d; i++) {
            scanf("%d", &hd[i]);
        }
        for (int i = 0; i < w; i++) {
            r += hw[i];
            for (int j = 0; j < d; j++) {
                if (hd[j] == hw[i]) {
                    hd[j] = -1;
                    break;
                }
            }
        }
        for (int i = 0; i < d; i++) {
            if (hd[i] >= 0) r += hd[i];
        }
        printf("%d\n", r);
    }
    return 0;
}