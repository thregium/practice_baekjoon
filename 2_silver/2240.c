#include <stdio.h>

/*
문제 : 1초에 한번씩 두 나무 중 한 곳에서 자두가 떨어질 때, 최대 w번만 움직여서 받을 수 있는 자두의 수를 구한다. (시작 위치는 1번 나무이고, 움직이는 데에는 시간이 걸리지 않는다.)

해결 방법 : 각 시간과 움직인 횟수별로 자두를 최대한 받을 수 있는 횟수를 저장한다. 특정한 시각과 움직인 횟수에서 받을 수 있는 자두의 수는 1초 전의 자두의 수와
1초 전의 1회 덜 움직였을 때의 자두의 수 가운데 큰 것에서 현재 위치에서 자두를 받을 수 있는 경우 1을 더하고, 아닌 경우 그대로이다.
현재 위치에서 자두를 받는 방법은 움직인 횟수가 홀수 번이면 2번, 짝수 번이면 1번 위치에 떨어진 경우이다.

주요 알고리즘 : 다이나믹 프로그래밍
*/

int plum[1024], mem[32][1024];

int big(int a, int b) {
    return a > b ? a : b;
}

int main(void) {
    int t, w, p, b = -1;
    scanf("%d %d", &t, &w);
    for (int i = 1; i <= t; i++) {
        scanf("%d", &plum[i]);
    }

    for (int i = 0; i <= w; i++) {
        for (int j = 1; j <= t; j++) {
            p = !((plum[j] - 1) - (i % 2));
            mem[i][j] = big(mem[i][j - 1] + p, i > 0 ? (mem[i - 1][j - 1] + p) : 0);
        }
        b = big(b, mem[i][t]);
    }
    printf("%d", b);
    return 0;
}