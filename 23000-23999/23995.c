#include <stdio.h>
#include <string.h>

/*
문제 : 양 옆 글자의 합 % 26을 하여 나온 문자열이 주어진다. 이때, 이 문자열을 해당 연산 이전으로 한
문자열이 유일한 지 구하고, 유일하다면 그러한 문자열을, 그렇지 않다면 "AMBIGUOUS"를 출력한다.
각 글자의 값은 각 글자 - 'A'의 값과 같다. 문자열의 길이는 50 이하다.

해결 방법 : 우선 양 끝에서 2번째 문자는 바깥쪽 문자와 같기 때문에 반드시 알 수 있다.
거기서부터 2칸씩 옮기며 문자들에 대해 차를 구하며 문자들을 알아갈 수 있다. 하지만 문자열의 길이가
홀수인 경우에는 홀수 번째 문자들을 알 수 없기 때문에 답이 유일하지 않고,
따라서 "AMBIGUOUS"를 출력해야 한다.

주요 알고리즘 : 문자열, 수학

출처 : GKS 2017C A번
*/

char w[64], y[64];

int main(void) {
    int t, l;
    scanf("%d", &t);
    for (int tt = 1; tt <= t; tt++) {
        scanf("%s", w);
        l = strlen(w);
        y[l] = '\0';
        y[1] = w[0];
        for (int i = 3; i < l; i += 2) {
            y[i] = ((w[i - 1] - 'A') + 2600 - (y[i - 2] - 'A')) % 26 + 'A';
        }
        y[l - 2] = w[l - 1];
        for (int i = l - 4; i >= 0; i -= 2) {
            y[i] = ((w[i + 1] - 'A') + 2600 - (y[i + 2] - 'A')) % 26 + 'A';
        }
        printf("Case #%d: %s\n", tt, (l & 1) ? "AMBIGUOUS" : y);
    }
    return 0;
}