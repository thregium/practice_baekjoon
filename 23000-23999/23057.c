#include <stdio.h>

/*
문제 : N(N <= 20)개의 자연수가 주어질 때, 자연수들 가운데 일부를 더해서 만들 수 없는
(모든 자연수의 합 이하인) 자연수의 개수를 구한다. 각 자연수는 1억 이하로 주어진다.
(메모리 제한 : 512MB)

해결 방법 : 메모리 제한이 자릿수당 1바이트로는 모자라도 1비트로는 들어가는 크기이므로 2억 5천만정도 크기를 갖는
char형 배열에 자연수의 등장 상태를 저장하며 풀 수 있다. 결괏값을 (모든 자연수의 합)으로 초기화한 후,
아직 등장하지 않은 자연수가 나올 때 마다 결괏값에서 1씩 뺀다. 각 등장은 비트 단위로 표시한다.
모든 경우를 확인한 다음 결괏값을 출력하면 된다.

주요 알고리즘 : 자료구조, 비트셋, 브루트 포스

출처 : 충남대 5회 C번
*/

int a[32];
char chk[268435456];

int main(void) {
    int n, r, s = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
        s += a[i];
    }
    r = s;
    for (int i = 1; i < (1 << n); i++) {
        s = 0;
        for (int j = 0; j < n; j++) {
            if (i & (1 << j)) s += a[j];
        }
        if (chk[s >> 3] & (1 << (s & 7))) continue;
        else {
            chk[s >> 3] |= (1 << (s & 7));
            r--;
        }
    }
    printf("%d", r);
    return 1;
}