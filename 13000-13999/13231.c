#include <stdio.h>
#define MOD 1000000007

/*
문제 : N * 2(N <= 500)자리 수 가운데 앞 절반과 뒷 절반의 숫자 합이 같은 수의 갯수를 구한다.

해결 방법 : 앞부분과 뒷부분은 서로 독립적으로 볼 수 있다. 그러므로 N자리 수를 숫자 합 별로 갯수를 센 후
제곱하여 더하면 답을 알아낼 수 있다. (앞부분과 뒷부분에서 숫자 합의 갯수는 서로 같을 것이므로)
각 숫자 합의 갯수은 다이나믹 프로그래밍을 통해 알아낼 수 있다. 0자리 수의 숫자 합은 0 1가지이다.
그리고 N자리 숫자의 합을 X로 만들 수 있는 가짓수는 N - 1자리 숫자의 합이 X - 9부터 X일 때 까지 각각 뒤에 9 ~ 0을 붙여 만들 수 있다.
이것을 점화식으로 하여 각 숫자 합 별 갯수를 알아낸 후, 전부 제곱하여 더한 수를 출력하면 된다. 제곱하는 과정에서 오버플로에 주의한다.

주요 알고리즘 : 다이나믹 프로그래밍, 조합론

출처 : AIPO 2015S 2번
*/

int mem[512][5120]; //[자리의 갯수][자릿수 합]

int main(void) {
    int t, n, r;
    mem[0][0] = 1;
    for (int i = 1; i <= 500; i++) {
        for (int j = 0; j <= i * 9; j++) {
            for (int k = 0; k <= 9 && j - k >= 0; k++) {
                mem[i][j] = (mem[i][j] + mem[i - 1][j - k]) % MOD; //점화식
            }
        }
    }
    scanf("%d", &t);
    for (int tt = 1; tt <= t; tt++) {
        scanf("%d", &n);
        r = 0;
        for (int i = 0; i <= n * 9; i++) {
            r = (r + (long long)mem[n][i] * mem[n][i]) % MOD; //제곱하여 더한다
        }
        printf("Case #%d: %d\n", tt, r);
    }
    return 0;
}