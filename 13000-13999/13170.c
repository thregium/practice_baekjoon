#include <stdio.h>

/*
문제 : N(N <= 1000)개의 수정 가운데 강도가 K번째인 수정을 부수려고 한다. 각 수정의 강도는 P(P <= 2000)이하며 0보다 큰 실수이다.
이때, K번째 수정을 강도보다 W(W <= P) 이상 세게 치면 폭발한다고 할 때, 최악의 경우에도 K번째 수정을 폭발시키지 않고
부술 수 있는 쳐야 할 최소 횟수를 구한다. 한번 부순 수정은 다시 칠 수 없다.

해결 방법 : K번째 수정 외의 수정을 치더라도 K번째 수정의 정확한 강도를 알기는 어렵다. (K번째 수정의 강도와 강도가 크게
차이 날 수 있기 때문), 따라서 K번째 수정을 계속 치면 되는데, 폭발을 일으키지 않으려면 마지막으로 친 강도보다
W보다 더 많이 세게 쳐서는 안 된다.(현재 친 강도 - W 이하가 수정의 강도라면 폭발하므로).
따라서, 첫 번째에는 W, 두 번째에는 2W ... 이런 식으로 쳐가다가 P 이상의 강도가 될 때 까지 반복해야 한다.
이때까지 치는 횟수를 계산하면 p / w를 올림한 값이 되고, (p + w - 1) / w로 계산할 수 있다.

주요 알고리즘 : 그리디 알고리즘, 수학

출처 : UCPC 2016 L번
*/

int main(void) {
    int n, k, p, w;
    scanf("%d %d %d %d", &n, &k, &p, &w);
    printf("%d", (p + w - 1) / w);
    return 0;
}