#include <stdio.h>

/*
문제 : 정육각형 형태로 이루어진 픽셀들로 구성된 화면이 있다. 이 화면에서 해당 칸과 주위 6칸의
픽셀 상태에 따라 상태가 변하는 필터를 적용하려고 한다. 필터를 연속으로 2번 적용한 것이
원래 상태와 같은 지 구한다. 필터의 값은 주위 7칸의 상태 각각에 대한 결과 비트 값의 배열로 주어진다.

해결 방법 : 주위 7칸과 그 밖 1줄씩 19칸에 대해서 비트의 모든 상태에 대해 필터를 2번 적용하였을 때,
가운데 칸이 1번 적용하였을 때와 같은 지 확인한다. 1번이라도 다른 경우가 있다면 다른 것이다.

주요 알고리즘 : 브루트 포스, 비트마스킹

출처 : JAG 2014P K번
*/

char s[256];
int bit[3][19];
int adj[7][7] = { {13, 14, 12, 0, 1, 2, 3}, {14, 15, 0, 1, 16, 3, 4}, {12, 0, 11, 2, 3, 10, 5},
    {0, 1, 2, 3, 4, 5, 6}, {1, 16, 3, 4, 17, 6, 18}, {2, 3, 10, 5, 6, 9, 8}, {3, 4, 5, 6, 18, 8, 7} };

int same(void) {
    int t;
    for (int i = 0; i < 7; i++) {
        t = 0;
        for (int j = 0; j < 7; j++) t += (bit[0][adj[i][j]] << j);
        bit[1][i] = s[t] - '0';
    }
    t = 0;
    for (int i = 0; i < 7; i++) t += (bit[1][adj[3][i]] << i);
    bit[2][3] = s[t] - '0';

    return bit[2][3] == bit[1][3];
}

int main(void) {
    int r;
    while (1) {
        scanf("%s", s);
        if (s[0] == '#') break;
        r = 1;
        for (int i = 0; i < (1 << 19); i++) {
            for (int j = 0; j < 19; j++) bit[0][j] = ((i >> j) & 1);
            r &= same();
        }
        printf("%s\n", r ? "yes" : "no");
    }
    return 0;
}