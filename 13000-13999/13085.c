#include <stdio.h>

/*
문제 : N(N <= 100000) 길이의 '>'와 '<'로 이루어진 발판들이 있다.
'>'를 밟으면 오른쪽, '<'를 밟으면 왼쪽으로 다음 발판까지 이동하며, 한번 밟은 발판은 사라진다.
이때, 어떤 발판에서 출발하여 한 번에 가장 많이 발판을 제거할 때의 제거한 발판의 수를 구한다.

해결 방법 : 만약 양쪽 끝 중 한쪽이 안쪽으로 들어간 발판인 경우 안쪽의 발판 가운데 적어도 하나는
안쪽으로 들어간 끝 발판을 밟고 바깥으로 나가게 되어 모든 발판을 제거 가능하다.
그러한 경우가 아니라면 발판을 최소한으로 지운 다음 그러한 형태로 만들면 N - 지운 발판 수 만큼의
발판을 제거 가능하다. 지운 발판의 수는 양쪽 끝에 있는 연속으로 바깥으로 나가는 발판의 길이
중 더 짧은 것과 같다. 따라서 N에서 그 값을 빼면 답이 된다.

주요 알고리즘 : 애드 혹?

출처 : JAG 2015P D번
*/

char s[103000];

int small(int a, int b) {
    return a < b ? a : b;
}

int main(void) {
    int n, l = 0, r = 0;
    scanf("%d", &n);
    scanf("%s", s);
    for (int i = 0; i < n; i++) {
        if (s[i] == '<') l++;
        else break;
    }
    for (int i = n - 1; i >= 0; i--) {
        if (s[i] == '>') r++;
        else break;
    }
    printf("%d", n - small(l, r));
    return 0;
}