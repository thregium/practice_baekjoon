#include <stdio.h>
#include <vector>
#include <tuple>
using namespace std;
//어떤 과학의 초전자포

/*
문제 : 2 * 2 * 2 * 2 * N(N <= 10^9) 크기의 격자를 1 * 2 크기의 조각으로 나누는 방법이 몇 가지인지 구한다.

해결 방법 : 각 줄의 칸들을 0부터 15까지로 번호를 붙인 다음, 줄 순 -> 번호 순으로 칸들을 정렬했을 때, 마지막 칸이 어떤 칸인지,
그 칸의 이전 16개 칸의 상태는 어떤지를 비트마스킹으로 저장한다. 단, 16개보다 이전 칸들에 대해서는 전부 차있어야 한다.
각 칸에 대해 현재 칸을 마지막 칸으로 했을 때 현재 상태에서 인접한 이전 칸이 비어있다면 현재 상태의 수에 이전 상태의 수를 전부 더한다.
이전 상태는 마지막 칸이 다르므로 비트 이동 연산을 통해 움직인 칸수만큼 왼쪽으로 비트를 민 다음, 새로 들어온 비트들은 전부 1로 채운다.
그리고 인접한 칸에 해당하는 비트를 지우면 된다. 인접한 칸은 16까지 비트로 나타냈을 때, 비트 하나만 차이가 나는 칸들이다.

이러한 형태는 행렬식의 형태로 표현 가능하기 때문에 위 연산을 통해 낮은 N(약 200) 이하에 대한 값을 구한 다음,
벌래캠프-매시를 통해 큰 N에  대해서 값을 얻는 것이 가능해진다.

주요 알고리즘 : DP, 비트마스킹DP, 벌래캠프-매시
*/

//int mem[4096][65536], arr[1024];
vector<int> v = { 272, 589185, 930336768, 853401154, 217676188, 136558333, 415722813, 985269529, 791527976, 201836136, 382110354, 441223705, 661537677, 641601343, 897033284, 816519670, 365311407, 300643484, 936803543, 681929467, 462484986, 13900203, 657627114, 96637209, 577140657, 600647073, 254604056, 102389682, 811580173, 592550067, 587171680, 526467503, 265885773, 951722780, 219627841, 371508152, 283501391, 159234514, 439380999, 722868959, 125599834, 351398134, 456317548, 365496182, 614778702, 502680047, 193063685, 309004764, 743901785, 870955115, 312807829, 160375015, 691844624, 137034372, 350330868, 895680450, 282610535, 317897557, 28600551, 583305647, 539409363, 327406961, 627805385, 680183978, 681299085, 954964592, 743524009, 788048339, 699454626, 666369521, 857206425, 490463127, 477198247, 599963928, 21247982, 107843532, 753662937, 239039324, 608530376, 523383010, 654448101, 801430395, 393034561, 93313778, 983052766, 240336620, 825539982, 525118275, 563899476, 706271688, 547405697, 477082486, 664058071, 353207278, 729486413, 795704637, 999271072, 540749624, 411451016, 736422999, 879369181, 918733916, 982303557, 512499644, 261033810, 391766409, 334092786, 931794834, 854181848, 821090190, 751839258, 433126935, 571194155, 52438113, 552977155, 320805296, 173355929, 969659468, 258854248, 159509877, 374487748, 401382023, 44060530, 510164669, 336596764, 652050424, 373872552, 517226592, 719871041, 43959496, 235333335, 304962191, 253114421, 43638769, 361871585, 8060121, 147014624, 114846460, 430864038, 368951246, 863795701, 36066788, 971606149, 935875286, 486724123, 73790652, 236936530, 307697424, 753314001, 40450345, 529462842, 166162047, 974102330, 600865526, 63237062, 749041914, 670937123, 806399597, 776678839, 842565920, 608499253, 469062485, 842196981, 247762946, 778570576, 237951782, 286343384, 988318575, 147255879, 905747089, 711062313, 21396079, 826846622, 443781794, 786474911, 400737121, 844768961, 686214818, 590050845, 855473150, 18501778, 33258755, 398169058, 811192244, 710397887, 591757177, 775311969, 168256434, 509615161, 489764304, 605188191, 498085780, 164388183, 524662873, 322602324, 853641480, 205349527, 308211944, 93153206, 734257752, 68829302, 443687521, 524241394, 591557198, 308656747, 511733449, 943095360, 194572043, 420913382, 679842332, 684364764, 134540921, 551103000, 700528141, 54414645, 814404379, 3421752, 316740512, 853118601, 894201609, 877520795, 244106463, 358840411, 411662431, 953845173, 239397728, 391633640, 745859650, 6417562, 246353318, 900069523, 877218664, 234394818, 171521822, 184466314, 316351773, 353811494, 617940271, 731132804, 656046921, 2378554, 305082811, 860468755, 877839522, 884387573, 83314799, 753963703, 702751847, 739819061, 2908431, 897890934, 45761348, 828368065, 248920872 };
const int mod = 1000000007;
using lint = long long;
lint ipow(lint x, lint p) {
	lint ret = 1, piv = x;
	while (p) {
		if (p & 1) ret = ret * piv % mod;
		piv = piv * piv % mod;
		p >>= 1;
	}
	return ret;
}
vector<int> berlekamp_massey(vector<int> x) {
	vector<int> ls, cur;
	int lf, ld;
	for (int i = 0; i < x.size(); i++) {
		lint t = 0;
		for (int j = 0; j < cur.size(); j++) {
			t = (t + 1ll * x[i - j - 1] * cur[j]) % mod;
		}
		if ((t - x[i]) % mod == 0) continue;
		if (cur.empty()) {
			cur.resize(i + 1);
			lf = i;
			ld = (t - x[i]) % mod;
			continue;
		}
		lint k = -(x[i] - t) * ipow(ld, mod - 2) % mod;
		vector<int> c(i - lf - 1);
		c.push_back(k);
		for (auto& j : ls) c.push_back(-j * k % mod);
		if (c.size() < cur.size()) c.resize(cur.size());
		for (int j = 0; j < cur.size(); j++) {
			c[j] = (c[j] + cur[j]) % mod;
		}
		if (i - lf + (int)ls.size() >= (int)cur.size()) {
			tie(ls, lf, ld) = make_tuple(cur, i, (t - x[i]) % mod);
		}
		cur = c;
	}
	for (auto& i : cur) i = (i % mod + mod) % mod;
	return cur;
}
int get_nth(vector<int> rec, vector<int> dp, lint n) {
	int m = rec.size();
	vector<int> s(m), t(m);
	s[0] = 1;
	if (m != 1) t[1] = 1;
	else t[0] = rec[0];
	auto mul = [&rec](vector<int> v, vector<int> w) {
		int m = v.size();
		vector<int> t(2 * m);
		for (int j = 0; j < m; j++) {
			for (int k = 0; k < m; k++) {
				t[j + k] += 1ll * v[j] * w[k] % mod;
				if (t[j + k] >= mod) t[j + k] -= mod;
			}
		}
		for (int j = 2 * m - 1; j >= m; j--) {
			for (int k = 1; k <= m; k++) {
				t[j - k] += 1ll * t[j] * rec[k - 1] % mod;
				if (t[j - k] >= mod) t[j - k] -= mod;
			}
		}
		t.resize(m);
		return t;
	};
	while (n) {
		if (n & 1) s = mul(s, t);
		t = mul(t, t);
		n >>= 1;
	}
	lint ret = 0;
	for (int i = 0; i < m; i++) ret += 1ll * s[i] * dp[i] % mod;
	return ret % mod;
}
int guess_nth_term(vector<int> x, lint n) {
	if (n < x.size()) return x[n];
	vector<int> v = berlekamp_massey(x);
	if (v.empty()) return 0;
	return get_nth(v, x, n);
}

int main(void) {
    int n, x, r, row, last, last2, shiftpos, shiftpos2, t;
    scanf("%d", &n);
    
	/*
	//대충 DP
    mem[31][65535] = 1;
    for (int i = 32; i < 4096; i++) {

        row = (i & 15);
        for (int j = 1; j < 65536; j++) {

            int tmp[32] = { 0, };
            last = -1;
            for (int k = 0; k < 16; k++) {
                tmp[k + row] = 1 & (j >> k);
                if (tmp[k + row]) last = k;
            }
            last2 = -1;
            for (int k = 0; k < last; k++) {
                if (tmp[k + row]) last2 = k;
            }
            shiftpos = ((j << (16 - last)) + (1 << (16 - last)) - 1) & 65535;
            shiftpos2 = ((j << (16 - last2)) + (1 << (16 - last2)) - 1) & 65535;
            if (j & 1) {
                if (j == 1) mem[i][j] = (mem[i][j] + mem[i - 17][65535]) % mod;
                else mem[i][j] = (mem[i][j] + mem[i - (16 - last)][shiftpos - ((1 << (16 - last)) & 65535)]) % mod;
            }

            for (int k = 16; k < 16 + row; k++) {
                if (!tmp[k]) continue;
                t = 0;
                for (int p = row; p & 15;) {
                    x = p & -p;
                    p -= x;
                    if (row - x == (k & 15)) t = 1;
                }
                if (!t) continue;

                if (j == 65535) {
                    j = j;
                }
                if (((k - row) & 15) != last) {
                    mem[i][j] = (mem[i][j] + mem[i - (16 - last)][shiftpos - (1 << (k - row + (16 - last)))]) % mod;
                    continue;
                }

                mem[i][j] = (mem[i][j] + mem[i - (16 - last2)][shiftpos2]) % mod;
            }

        }

        if ((i & 15) == 15) {
            //printf("(N = %d): %d\n", i, mem[i][65535]);
			printf("%d, ", mem[i][65535]);
            arr[(i >> 4) - 1] = mem[i][65535];
        }
    }
	*/

	printf("%d\n", guess_nth_term(v, n - 1));
    return 0;
}