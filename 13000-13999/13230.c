#include <stdio.h>
#include <string.h>

/*
문제 : 두 개의 이진수가 있을 때, 위쪽 이진수를 아래쪽 이진수로 바꾸는 데 드는 최소의 연산 회수를 출력한다.
위쪽 이진수에는 ?가 들어있을 수 있다.
연산으로는 1. 0을 1로 바꾼다. 2. 두 자릿수를 서로 바꾼다. 3. ?를 어떤 수로 바꾼다 의 3가지가 있다.

해결 방법 : 먼저, 두 수의 길이를 잰다. 길이가 서로 다르다면 아래 수를 만들 수 없다.
그 다음으로, ?의 수와 두 수의 1의 갯수를 각각 샌다. 1을 0으로 바꿀 수 없기 때문에 위쪽 1이 더 많다면 아래 수를 만들 수 없다.
세는 것이 끝나면 1의 갯수가 차이난다면 아래 숫자가 1인 ?를 차이만큼 1로 바꾼다. 그 후, 나머지 숫자는 0으로 바꾼다.
그럼에도 차이가 난다면 남아있는 0 가운데 아래 숫자가 1인 숫자들을 1로 바꾼다.
현재까지 바꾼 수의 갯수만큼에 (두 수 가운데 차이 나는 숫자의 갯수 / 2)만큼을 더한 값을 출력하면 된다.

(다른 풀이) : 먼저 두 수의 1의 갯수를 센다. 위쪽 1이 더 많다면 불가능함을 알 수 있다.
그 다음, 위쪽이 1이고 아래쪽이 0인 경우와 위쪽이 0이고 아래쪽이 1인 경우, 위쪽 숫자가 ?인 경우 3가지의 값을 각각 센다.
결괏값은 위쪽 숫자가 ?인 경우에 (앞쪽 2가지 가운데 큰 값)을 더한 것과 같다.

주요 알고리즘 : 그리디 알고리즘

출처 : AIPO 2015J 4번 / 2015S 1번
*/

char s[128], t[128];

int main(void) {
    int c, l, s1, q, t1, d;
    scanf("%d", &c);
    for (int cc = 1; cc <= c; cc++) {
        scanf("%s%s", s, t);
        s1 = 0;
        q = 0;
        t1 = 0;
        d = 0;
        l = strlen(s);
        if (strlen(t) != l) {
            printf("Case %d: -1\n", cc); //갯수가 맞지 않는 경우
            continue;
        }
        for (int i = 0; i < l; i++) {
            if (s[i] == '1') s1++; //위쪽 1의 갯수
            if (s[i] == '?') q++; //?의 갯수
            if (t[i] == '1') t1++; //아래쪽 1의 갯수
        }
        if (t1 < s1) {
            printf("Case %d: -1\n", cc); //위쪽 1이 더 많은 경우
            continue;
        }
        for (int i = 0; i < l; i++) {
            if (s[i] == '?' && t[i] == '1' && s1 < t1) {
                s[i] = '1'; //위쪽 ? 가운데 1로 만들 수 있는 것들을 있는대로 1로 만든다.
                s1++;
            }
        }
        for (int i = 0; i < l; i++) {
            if (s[i] == '?' && s1 < t1) {
                s[i] = '1'; //여전히 넣어야 할 1이 남는 경우 아래 숫자가 0임에도 1을 넣는다.
                s1++;
            }
            else if (s[i] == '?') {
                s[i] = '0'; //균형이 맞춰진 경우 나머지는 전부 0을 넣는다.
            }
        }
        for (int i = 0; i < l; i++) {
            if (s[i] == '0' && t[i] == '1' && s1 < t1) {
                s[i] = '1'; //위와 아래의 1 갯수가 맞지 않는 경우 남은 0을 1로 만든다.
                s1++;
                q++;
            }
        }
        for (int i = 0; i < l; i++) {
            if (s[i] != t[i]) d++;
        }
        if (d & 1) return 1;
        if (t1 > s1) printf("Case %d: -1\n", cc);
        else printf("Case %d: %d\n", cc, (d >> 1) + q);
    }
    return 0;
}