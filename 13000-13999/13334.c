#include <stdio.h>
#include <stdlib.h>

/*
문제 : 수직선상에 선분 N(N <= 100000)개가 있을 때, 크기 D(D <= 2 * 10^9) 이하인 구간 중
가장 선분을 많이 포함하는 구간이 포함하는 선분의 수를 구한다.

해결 방법 : 각 선분의 시작점과 끝점들을 각각 따로 정렬한 후, 수직선의 처음부터 시작점들을 기준으로 구간들을 읽어가기 시작한다.
이때, 현재 보고 있는 시작점에서 D 이하로 오른쪽에 있는 끝점들에 대해 1씩 카운터의 값에 더해준다. 단, 시작점을 이미 읽은 선분들에 대해서는 더하지 않는다.
카운터의 값이 현재 결괏값보다 크다면 결괏값을 업데이트하고, 현재 시작점을 읽는다. 카운터에 더했던 선분이라면 카운터에서 1을 뺀다.
이를 선분이 끝날 때 까지 반복하여 최댓값을 구하면 된다.

주요 알고리즘 : 스위핑, 정렬

출처 : Daejeon 2016 J번
*/

int h[103000][2], o[103000][2]; //h : 시작점(0 : 위치, 1 : 번호), o : 끝점(0 : 위치, 1 : 번호)
int s[103000]; //각 선분들의 정보(0 : 읽지 않음, 1 : 시작점만, 2 : 끝점만, 3 : 모두 읽음)

int cmp1(const void* a, const void* b) {
    int ai = *(int*)a;
    int bi = *(int*)b;
    return ai > bi ? 1 : ai == bi ? 0 : -1;
}

void swap(int* x, int* y) {
    int t = *x;
    *x = *y;
    *y = t;
}

int main(void) {
    int n, c, d, j = 0, cnt = 0, r = 0; //j : 현재 읽을 끝점의 번호, cnt : 카운터 값, r : 결괏값
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &h[i][0], &o[i][0]);
        h[i][1] = i;
        o[i][1] = i;
        if (h[i][0] > o[i][0]) swap(&h[i][0], &o[i][0]); //순서가 맞지 않는 경우 시작점과 끝점으로 바꿔준다.
    }
    o[n][0] = 1234567890; //끝점을 무한대로 맞추기
    scanf("%d", &d);
    qsort(h, n, sizeof(int) * 2, cmp1);
    qsort(o, n, sizeof(int) * 2, cmp1);

    for (int i = 0; i < n; i++) {
        while (o[j][0] <= h[i][0] + d) {
            //h[i][0]보다 커질 때 까지 j를 올림
            s[o[j][1]] += 2;
            if (s[o[j][1]] == 2) cnt++; //아직 시작점을 지나지 않은 선분이라면 카운트
            j++;
        }
        if (cnt > r) r = cnt; //업데이트
        s[h[i][1]] += 1;
        if (s[h[i][1]] == 3) cnt--; //카운트했던 선분이라면 카운트 취소
    }
    printf("%d", r);
    return 0;
}