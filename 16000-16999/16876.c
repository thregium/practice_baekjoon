#include <stdio.h>

/*
문제 : 4자리 자연수 N(0으로 시작할 수 있다.)과 100 이하의 음이 아닌 정수 M이 주어질 때,
두 사람이 최적의 전략으로 게임을 진행한다면 M번의 턴이 지난 후 누가 이기는지 구한다.
게임은 N을 구성하는 숫자 가운데 하나를 1 올리는 것으로 턴을 진행한다. 해당 숫자가 9라면 해당 숫자를 0으로 바꾼다.
마지막 턴에 수가 N보다 크다면 선공이 이기고, 아니면 후공이 이긴다.

해결 방법 : 마지막 턴부터 역순으로 게임을 진행해 나간다. 해당 턴의 플레이어를 확인하고,
해당 턴에서 바꿀 수 있는 수 가운데 해당 플레이어에게 가장 유리한 것을 선택한다. 이를 반복해 1번째 턴으로 돌아오면
그때 이기는 플레이어를 찾으면 된다.

주요 알고리즘 : DP, 게임 이론
*/

int mem[128][10000], nup[10240][4];

int main(void) {
    int n, m, t = 1;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 10000; j++) {
            if (j / t % 10 == 9) nup[j][i] = j - (t * 9); //j에서 이동 가능한 수
            else nup[j][i] = j + t;
        }
        t *= 10;
    }
    scanf("%d %d", &n, &m);
    for (int i = n + 1; i < 10000; i++) {
        mem[0][i] = 1; //결과
    }
    for (int i = 1; i <= m; i++) {
        if ((m - i + 1) & 1) {
            //선공
            for (int j = 0; j < 10000; j++) {
                t = 0;
                for (int k = 0; k < 4; k++) {
                    if (mem[i - 1][nup[j][k]]) t = 1;
                }
                mem[i][j] = t;
            }
        }
        else {
            //후공
            for (int j = 0; j < 10000; j++) {
                t = 1;
                for (int k = 0; k < 4; k++) {
                    if (!mem[i - 1][nup[j][k]]) t = 0;
                }
                mem[i][j] = t;
            }
        }
    }
    if (mem[m][n]) printf("koosaga");
    else printf("cubelover");
    return 0;
}