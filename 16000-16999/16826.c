#include <stdio.h>

/*
문제 : 1000회 이하로 왼쪽 또는 오른쪽으로 돌린 기록이 주어질 때, 오른쪽으로 몇 바퀴 돌린 것인지 구한다.
한 바퀴 돌린 것의 정의는 북쪽에서 시작해 오른쪽 방향으로 이동한 이후 동, 남, 서를 순서대로 이동 후 북쪽으로 돌아오는 것이다.
단, 중간에 북쪽으로 돌아온다면 처음부터 다시 시작한다.

해결 방법 : 맨 위쪽에서 시작해 현재까지 돌린 최대 방향과 현재 방향을 기록한다. 만약 북쪽인 경우에는 최대 방향 서쪽에서
오른쪽으로 돌린 것이면 한 바퀴를 추가하고, 어떤 경우든 최대 방향을 북쪽으로 설정해 놓는다.
최대 방향의 오른쪽으로 오른쪽 이동을 통해 간 경우에는 최대 방향을 한칸 오른쪽으로 바꾼다.

주요 알고리즘 : 구현, 시뮬레이션

출처 : JAG 2018SuD3 A번
*/

char s[1024];

int main(void) {
    int r = 0, d = 0, p = -2;
    scanf("%s", s);
    for (int i = 0; s[i]; i++) {
        if (s[i] == 'L') d = ((d + 3) & 3);
        else d = ((d + 1) & 3);
        if (d == 0) {
            if (p == 3 && s[i] == 'R') r++;
            p = -2;
        }
        if (d == p + 1 && s[i] == 'R') p = d;
        if (p < 0 && d == 1 && s[i] == 'R') p = 1;
    }
    printf("%d", r);
    return 0;
}