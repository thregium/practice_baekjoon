#include <stdio.h>

/*
문제 : 8 * 8 크기의 체스판에서 벽의 위치가 주어진다. 체스판의 왼쪽 아래에 있는 킹을 움직여 오른쪽 위로
이동시킬 수 있는 지 구한다. 단, 매번 킹을 움직일 때 마다 벽은 아래로 1칸씩 내려오고,
벽이 킹과 겹치게 되면 더이상 움직일 수 없다.

해결 방법 : 정점을 이동 횟수로 두면 플러드필을 통해 킹을 이동시키며 도달 가능한지 구할 수 있다.
매번 이동시킬 때에는 그 횟수에 벽에 부딪히는지 확인하면 되고, 이동시킨 다음에는 해당 위치가 그 횟수에서 벽인지 확인해서
벽인 경우 다음 위치를 보면 된다. 이때, 무한정 탐색이 가능하기 때문에 일정 횟수(24회)가 넘어가면 탐색을 종료한다.
탐색이 종료된 후에는 오른쪽 위 칸에 방문한 적이 있는 지 확인하고 그렇다면 이동 가능한 것이고,
그런 적이 없다면 이동 불가능한 것이라고 출력하면 된다.

주요 알고리즘 : 그래프 이론, 플러드필
*/

char s[16][16];
int vis[8][8][32];
int dxy[9][2] = { {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {0, 0} };

int isvalid(int x, int y, int c) {
    if (x < 0 || y < 0 || x >= 8 || y >= 8 || c >= 32) return 0;
    if (vis[x][y][c]) return 0;
    if (x >= c - 1 && s[x - c + 1][y] == '#') return 0;
    return 1;
}

void dfs(int x, int y, int c) {
    vis[x][y][c] = 1;
    if (x >= c && s[x - c][y] == '#') return;
    for (int i = 0; i < 9; i++) {
        if (isvalid(x + dxy[i][0], y + dxy[i][1], c + 1)) dfs(x + dxy[i][0], y + dxy[i][1], c + 1);
    }
}

int main(void) {
    int r = 0;
    for (int i = 0; i < 8; i++) {
        scanf("%s", s[i]);
    }
    dfs(7, 0, 0);
    for (int i = 31; i >= 0; i--) {
        if (vis[0][7][i]) r = 1;
    }
    printf("%d", r);
    return 0;
}