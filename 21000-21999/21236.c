#include <stdio.h>

/*
문제 : 좌표평면상에 N(N <= 100000)개의 점이 주어진다. 각 점의 위치는 0 이상 1000 이하의 정수로 된 좌표로 주어진다.
이때, 각 점이 주어질 때 마다 해당 점까지 주어질 때 인접한 점의 개수가 3인 점의 개수를 구한다.
인접한 점은 X좌표가 같고 Y좌표의 차이가 1이거나 X좌표의 차이가 1이고 Y좌표가 같은 점이다.
좌표가 같은 점은 주어지지 않는다.

해결 방법 : 점의 위치 범위가 작기 때문에 점이 있는 지점과 없는 지점들을 각각 표시할 수 있다.
각 점의 위치가 주어지면 주변 점들의 수를 확인하며 인접한 점이 3개인지 확인한다. 3개인 경우 결괏값에 1을 더한다.
또한, 인접한 점에 대해 인접한 점의 개수를 확인하여 새로 3개가 되거나 3개였지만 4개로 늘어난 점들을 각각 확인한다.
전자에서는 결괏값에 1을 더하고, 후자에서는 결괏값에 1을 뺀다. 이 계산이 끝날 때 마다의 결괏값을 매번 출력하면 된다.
결괏값들은 계속 보존하고 있어야 한다.

주요 알고리즘 : 구현

출처 : USACO 2021F B2번
*/

int chk[1024][1024];
int dxy[4][2] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };

int main(void) {
    int n, x, y, r = 0, cnt1, cnt2;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &x, &y);
        x += 13, y += 13;
        cnt1 = 0;
        chk[x][y] = 1;
        for (int j = 0; j < 4; j++) {
            if (chk[x + dxy[j][0]][y + dxy[j][1]]) {
                cnt1++;
                cnt2 = 0;
                for (int k = 0; k < 4; k++) {
                    if (chk[x + dxy[j][0] + dxy[k][0]][y + dxy[j][1] + dxy[k][1]]) cnt2++;
                }
                if (cnt2 == 4) r--;
                else if (cnt2 == 3) r++;
            }
        }
        if (cnt1 == 3) r++;
        printf("%d\n", r);
    }
    return 0;
}