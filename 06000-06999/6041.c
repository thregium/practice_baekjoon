#include <stdio.h>

/*
문제 : 4자리 자연수로 숫자 야구를 한다. 예상한 수와 답에서 같은 위치에 같은 숫자가 있다면 스트라이크가 추가되고,
스트라이크가 아니면서 다른 위치에 같은 숫자가 있다면 볼이 추가된다. 숫자 야구를 N(N <= 100)회 하는 동안
예상한 수와 스트라이크/볼의 개수가 주어지면 답이 될 수 있는 4자리 수 가운데 가장 작은 수를 출력한다.
단, 없다면 "NONE"을 출력한다.

해결 방법 : 1000부터 9999 사이 범위에 답이 있기 때문에 1000부터 9999까지의 모든 수를 한번씩 해보면 된다.
만약 N번의 결과가 모두 주어진 값과 같다면 그 값을 출력하고 프로그램을 종료하면 되고, 하나라도 다르다면 다음 수를 해 본다.
끝까지 답이 될 수 있는 값이 없다면 "NONE"을 출력하면 된다.

각 수의 숫자 야구 결과는 수를 숫자 단위로 분해한 다음, 스트라이크 여부를 먼저 판정한다. 스트라이크인 경우,
그 숫자는 이미 쓰였음을 표시해두어 이후 볼일 때에 쓰이지 않도록 조정한다.
그 다음에는 볼 여부를 판정한다. 아직 스트라이크에 쓰이지 않은 수 가운데 같은 수가 있는지 확인하면 된다.
볼일 때 역시 이미 쓰였음을 표시해둔다.

주요 알고리즘 : 브루트 포스, 구현

출처 : USACO 2010M B3번
*/

int guess[128][3];

int guessing(int x, int y) {
    int xs[4], ys[4];
    for (int i = 0; i < 4; i++) {
        xs[i] = x % 10;
        ys[i] = y % 10;
        x /= 10, y /= 10;
    }
    int r = 0;
    for (int i = 0; i < 4; i++) {
        //스트라이크 판정
        if (xs[i] == ys[i]) {
            xs[i] = -1;
            ys[i] = -1;
            r += 10;
        }
    }
    for (int i = 0; i < 4; i++) {
        //볼 판정
        if (xs[i] < 0) continue;
        for (int j = 0; j < 4; j++) {
            if (j == i) continue;
            if (xs[i] == ys[j]) {
                r++;
                xs[i] = -1;
                ys[j] = -1;
                break;
            }
        }
    }
    return r;
}

int main(void) {
    int n, x, t;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d %d %d", &guess[i][0], &guess[i][1], &guess[i][2]);
    }
    for (int i = 1000; i <= 9999; i++) {
        //브루트 포스
        t = 1;
        for (int j = 0; j < n; j++) {
            x = guessing(i, guess[j][0]);
            if (guess[j][1] * 10 + guess[j][2] != x) {
                t = 0;
                break;
            }
        }
        if (t) {
            printf("%d", i);
            return 0;
        }
    }
    printf("NONE");
    return 0;
}