#include <stdio.h>

/*
문제 : N(N <= 100000)명에게 돈을 빌리거나 빌려주었다. 빌리거나 빌려준 사람들이 일렬로 서있고, 처음에는 돈이 없는 상태다.
왼쪽 끝에서부터 빌려준 돈을 찾아서 돈을 빌린 사람한테 돌아가 돈을 갚아야 한다. 각 사람들이 서있는 거리는 1로 일정하고,
빌려준 돈이 빌린 돈보다 많다면 왼쪽 끝에서 출발해서 모든 돈을 갚고 빌려준 모든 돈을 회수해 오른쪽 끝으로 가는
최단거리를 구한다.

해결 방법 : 같은 곳은 최소한으로 들르는 것이 좋다. 또한, 많이 돌아가지 않을 수 있다면 가능한 짧게 돌아가는 것이 좋다.
같은 곳은 최대 3번이면 모든 빌려준 돈을 커버할 수 있는 것을 알 수 있다. 여기서 가능한 짧게 돌아가기 위해서는
현재까지 지나온 모든 빌린 사람의 돈의 합이 현재 갖고 있는 돈 이하가 되면 앞의 모든 돈을 갚으러 가는 것이다.
그러면 해당 구간은 전부 커버되기 때문에 다시 갈 필요가 없고 불필요하게 멀리 돌아가지도 않게 된다.

이를 위해서는 빌린 돈의 양과 빌린 사람 중 첫 사람의 위치, 현재 금액을 기록해 놓은 다음,
아직 빌린 돈이 없다면 첫 빌린 사람의 위치를 기록하고, 이후로는 빌린 돈의 양과 현재 금액을 이동한 사람마다 구해놓는다.
그러다가 현재 금액이 빌린 돈의 양 이상이 되면 첫 사람의 위치까지 갔다 온 다음, 지금까지 빌린 것을 없는 셈 치고
다시 이후의 부분을 확인한다. 이를 반복하여 마지막까지 이동한 거리가 답이 된다.

주요 알고리즘 : 그리디 알고리즘

출처 : USACO 2008M B1번
*/

int owe[103000];

int main(void) {
    int n, firstminus = -1, minuses = 0, balance = 0, dist = 0;
    scanf("%d", &n);
    dist = n;
    for (int i = 0; i < n; i++) {
        scanf("%d", &owe[i]);
        if (firstminus < 0 && owe[i] < 0) firstminus = i;
        if (owe[i] < 0) minuses -= owe[i];
        else balance += owe[i];
        
        if (balance >= minuses && firstminus >= 0) {
            dist += (i - firstminus) * 2;
            balance -= minuses;
            minuses = 0;
            firstminus = -1;
        }
    }
    printf("%d", dist);
    return 0;
}