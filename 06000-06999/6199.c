#include <stdio.h>

/*
문제 : N * N(N <= 100) 격자에 있는 값들('*', 'J', 'B')이 주어진다. 이때, '*' 하나를 'J'로 바꾸었을 때 'J'로 이루어진
가장 큰 정사각형(행, 열에 평행하지 않아도 됨)의 크기를 구한다. 만들 수 없다면 0을 출력한다.

해결 방법 : 모든 지점에 대해 해당 지점에서 시작하는 정사각형을 전부 만들어 본다.
정사각형은 해당 지점에서 오른쪽으로 1칸 이상, 아래로 0칸 이상 움직여 만들 수 있는 직선을 만들고,
그 직선에서 왼쪽 아래로 뻗어나가는 방식으로 만들 수 있다. 점이 N * N 범위를 벗어나는 경우는 무시하도록 한다.
그 다음, 네 점이 모두 N * N 범위 내에 들어오면 그 점들 중 'B'가 있는지 확인한다.
있다면 모두 'J'가 되는 것이 불가능할 것이다. 그 다음으로는 'J'가 네 점 중 3개 이상인지 확인하고,
3개 이상이라면 해당 값을 최댓값과 비교해 최댓값을 갱신한다. 모든 정사각형을 확인한 후 최댓값이 답이 된다.

주요 알고리즘 : 브루트 포스, 기하학

출처 : USACO 2006N S2번
*/

char s[128][128];

int main(void) {
    int n, r = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", s[i]);
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (s[i][j] == 'B') continue;
            for (int x = 0; i + x < n && j >= x; x++) {
                for (int y = 1; j + y < n && i + x + y < n; y++) {
                    if (s[i][j] == 'B' || s[i + x][j + y] == 'B' || s[i + y][j - x] == 'B'
                        || s[i + x + y][j - x + y] == 'B') continue;
                    if ((s[i][j] == 'J') + (s[i + x][j + y] == 'J') + (s[i + y][j - x] == 'J')
                        + (s[i + x + y][j - x + y] == 'J') >= 3) {
                        if (x * x + y * y > r) r = x * x + y * y;
                    }
                }
            }
        }
    }
    printf("%d", r);
    return 0;
}