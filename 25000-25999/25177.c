#include <stdio.h>

/*
문제 : 길이 N과 M(N, M <= 1000)인 배열 A, B가 주어질 때, A와 B의 같은 위치의 원소 가운데
A의 한 원소를 B의 같은 위치의 원소로 바꾸어 얻을 수 있는 최대 이득을 구한다.
배열 범위를 넘어가는 경우 0으로 간주하고, 바꾸지 않는 것도 가능하다.

해결 방법 : 0으로 초기화한 다음, b[i] - a[i]의 최댓값을 구한다. 크기 1000 이상의 전역 배열을 이용하면
범위를 넘어가는 경우를 0으로 초기화하여 간단히 범위를 넘어가는 경우도 해결 가능하다.

주요 알고리즘 : 구현

출처 : 서강대 2022S C번
*/

int a[1024], b[1024];

int main(void) {
    int n, m, r = 0;
    scanf("%d %d", &n, &m);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    for (int i = 0; i < m; i++) {
        scanf("%d", &b[i]);
    }
    for (int i = 0; i < n || i < m; i++) {
        if (b[i] - a[i] > r) r = b[i] - a[i];
    }
    printf("%d", r);
    return 0;
}