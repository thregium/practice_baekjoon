#include <stdio.h>

/*
문제 : 10000개 이하의 나무 블록을 일렬로 연결 가능한지 구한다. 1번 블록에서 시작해서 2번 블록에서 끝나야 한다.

해결 방법 : 먼저 1번 블록에서 끝나는지 확인하고, 그러한 경우 각 블록의 다음 블록이 맞아 들어가는지 구한다.
이때, 2번 블록의 다음 블록은 NULL로 생각한다. 모든 경우 맞다면 연결 가능하고, 하나라도 맞지 않는다면 연결 불가능하다.

주요 알고리즘 : 구현

출처 : Arab 2006 C번
*/

char s[10240];

int main(void) {
    int r = 1;
    for (int tt = 1;; tt++) {
        scanf("%s", s);
        if (s[0] == '0') break;
        r = (s[0] == '1');
        for (int i = 0; s[i]; i++) {
            if (s[i] == '1' && !(s[i + 1] == '4' || s[i + 1] == '5')) r = 0;
            if (s[i] == '2' && !(s[i + 1] == '\0')) r = 0;
            if (s[i] == '3' && !(s[i + 1] == '4' || s[i + 1] == '5')) r = 0;
            if (s[i] == '4' && !(s[i + 1] == '2' || s[i + 1] == '3')) r = 0;
            if (s[i] == '5' && !(s[i + 1] == '8')) r = 0;
            if (s[i] == '6' && !(s[i + 1] == '2' || s[i + 1] == '3')) r = 0;
            if (s[i] == '7' && !(s[i + 1] == '8')) r = 0;
            if (s[i] == '8' && !(s[i + 1] == '6' || s[i + 1] == '7')) r = 0;
            if (!r) break;
        }
        printf("%d. %s\n", tt, r ? "VALID" : "NOT");
    }
    return 0;
}