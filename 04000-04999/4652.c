#include <stdio.h>

/*
문제 : 80 이하의 길이를 갖는 소문자와 _로 이루어진 문자열이 있다. 이 문자열을 문제에 주어진 방법대로 암호화했을 때,
키가 주어지면 이 문자열을 복호화한 것을 출력한다.

해결 방법 : 암호화한 방식의 반대로 하면 된다. 즉 각 문자 묶음을 왼쪽으로 키값만큼 밀면 된다.
이때, 모듈로를 이용하되 음수가 되지 않도록 유의한다.

주요 알고리즘 : 구현, 문자열

출처 : MidC 2001 B번
*/

char s[128], s1[128], s2[128], s3[128];

int main(void) {
    int k1, k2, k3, l1, l2, l3, p1, p2, p3;
    while (1) {
        scanf("%d %d %d", &k1, &k2, &k3);
        if (k1 == 0) break;
        scanf("%s", s);
        l1 = 0, l2 = 0, l3 = 0, p1 = 0, p2 = 0, p3 = 0;
        for (int i = 0; s[i]; i++) {
            if ('a' <= s[i] && s[i] <= 'i') s1[l1++] = s[i];
            else if ('j' <= s[i] && s[i] <= 'r') s2[l2++] = s[i];
            else s3[l3++] = s[i];
        }
        for (int i = 0; s[i]; i++) {
            if ('a' <= s[i] && s[i] <= 'i') s[i] = s1[(p1++ + l1 * 3331 - k1) % l1];
            else if ('j' <= s[i] && s[i] <= 'r') s[i] = s2[(p2++ + l2 * 3331 - k2) % l2];
            else s[i] = s3[(p3++ + l3 * 3331 - k3) % l3];
        }
        printf("%s\n", s);
    }
    return 0;
}