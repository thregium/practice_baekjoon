#include <stdio.h>

/*
문제 : N(N <= 100)장의 카드를 가진 사람과 M(M <= 100)장의 카드를 가진 사람이 서로 카드를 1장씩 교환하여
카드에 쓰인 수의 합이 같게 만들 수 있는 지 구하고, 그러하다면 그렇게 교환하는 방법 가운데
교환하는 카드의 합이 가장 작은 것을 구한다. 아니라면 -1을 출력한다. 카드에 쓰인 수는 100 이하의 음이 아닌 정수이다.

해결 방법 : 서로의 현재 카드에 쓰인 값의 합을 먼저 구한 다음, 모든 서로의 카드 쌍에 대해
서로 카드를 교환하면 합이 같은 지 확인하고, 그러한 것 중 가장 작은 것을 구해나가면 된다.
그러한 것이 없던 경우 -1을 출력한다.

주요 알고리즘 : 구현, 브루트 포스

출처 : JDC 2008 A번
*/

int sa[128], sb[128];

int main(void) {
    int n, m, s1, s2, r1, r2;
    while (1) {
        scanf("%d %d", &n, &m);
        if (n == 0) break;
        s1 = 0, s2 = 0, r1 = 103000, r2 = 103000;
        for (int i = 0; i < n; i++) {
            scanf("%d", &sa[i]);
            s1 += sa[i];
        }
        for (int i = 0; i < m; i++) {
            scanf("%d", &sb[i]);
            s2 += sb[i];
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (s1 - sa[i] + sb[j] == s2 - sb[j] + sa[i]) {
                    if (sa[i] + sb[j] < r1 + r2) {
                        r1 = sa[i];
                        r2 = sb[j];
                    }
                }
            }
        }

        if (r1 == 103000) printf("-1\n");
        else printf("%d %d\n", r1, r2);
    }
    return 0;
}